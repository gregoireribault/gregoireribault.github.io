{"version":3,"file":"game.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAY;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AChHK;AACZ;AACA,CAAiE;AACrC;AACkB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,uBAAuB,iDAAE;AACzB;AACA,YAAY,iDAAE,mBAAmB,oDAAa;AAC9C,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,2DAAoB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,2DAAoB;AAC9C;AACA;AACA;AACgB;;;;;;;;;;;;;;;;;;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AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,uBAAuB,uBAAuB;AAC9C;AACA;;AAEA,oBAAoB,uBAAuB;AAC3C;AACA;;AAEA,oBAAoB,4BAA4B;AAChD;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,yBAAyB,4BAA4B;AACrD,yBAAyB,kCAAkC;AAC3D;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEc;;;;;;;;;;;;;;;;AC7GF;;AAEZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEgB;;;;;;;;;;;;;;;;;AChCJ;;AAEZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAE8B;;;;;;;;;;;;;;;;;;ACvFlB;;AAEZ,CAAqD;AACF;;AAEnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,WAAW,8DAAY;AACvB;;AAEA;AACA;AACA,yDAAyD,iDAAU;AACnE,uDAAuD,kDAAW;AAClE;AACA;;AAEA;AACA;AACA;AACA;;AAEyB;;;;;;;;;;;;;;;;;ACrCb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C/E;;AAEA;AACA;AACA;AACA,8BAA8B,qEAA8B;AAC5D,6BAA6B,qEAA8B;AAC3D;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO,EAAE,mEAA4B;AACrC,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA,kDAAkD,qEAA8B;AAChF;;AAEA;AACA;AACA;AACA,8BAA8B,qEAA8B;AAC5D,6BAA6B,qEAA8B;AAC3D;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO,EAAE,mEAA4B;AACrC,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA,kDAAkD,qEAA8B;AAChF;;AAEA;AACA;AACA;AACA,8BAA8B,qEAA8B;AAC5D,6BAA6B,qEAA8B;AAC3D;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO,EAAE,mEAA4B;AACrC,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA,iDAAiD,qEAA8B;AAC/E;;AAEA;AACA;AACA;AACA,8BAA8B,qEAA8B;AAC5D,6BAA6B,qEAA8B;AAC3D;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO,EAAE,mEAA4B;AACrC,KAAK;AACL;;AAEA;AACA,WAAW,0DAAmB;AAC9B;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,sBAAsB;AAC1C;AACA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,2BAA2B;AAC/C;AACA;AACA;AACA;AACA,sBAAsB,4BAA4B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI,8DAAY,MAAM,iDAAQ;AAC9B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI,8DAAY,MAAM,iDAAQ,UAAU,sDAAe;AACvD;AACA;AACA;AACA;AACA;AACA,UAAU,8DAAY,MAAM,iDAAQ,UAAU,sDAAe;AAC7D;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEgF;;;;;;;;;;;;;;;;;;;;;AC1VpE;AACZ;AACA,CAA2B;AACuB;AACkF;AACvE;AACf;AAC9C;AACA;AACA;AACA;AACA,iEAAe;AACf;AACA,4BAA4B,iDAAE,kBAAkB,wDAAiB,EAAE,yDAAkB,EAAE,uDAAgB,EAAE,wDAAiB;AAC1H;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,8BAA8B,iDAAE,kBAAkB,wDAAiB,EAAE,yDAAkB;AACvF;AACA;AACA;AACA,oBAAoB,wBAAwB;AAC5C;AACA;AACA;AACA;AACA,4DAA4D,+DAAW,uBAAuB,cAAc,mDAAY,gBAAgB,oDAAa,EAAE,EAAE,mDAAY,EAAE,oDAAa;AACpL,0BAA0B,0DAAM;AAChC;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA,oBAAoB,8DAAY;AAChC,qBAAqB,8DAAY;AACjC;AACA;AACA;AACA;AACA,8BAA8B,iDAAE,kBAAkB,uDAAgB,EAAE,wDAAiB;AACrF;AACA;AACA;AACA,oBAAoB,uBAAuB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,wDAAK;AAC9B;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;;;;;ACzEW;;AAEZ,CAA8F;;AAE9F;AACA,iBAAiB,mBAAO,CAAC,uDAAY;;AAErC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oBAAoB,mBAAmB;AACvC;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,sBAAsB;AAC1C;AACA;AACA;AACA;;AAEA,oCAAoC,8BAA8B;AAClE,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,oCAAoC,8BAA8B;AAClE,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,2BAA2B;AAC/C,sBAAsB,8BAA8B;AACpD;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,2BAA2B;AAC/C,sBAAsB,8BAA8B;AACpD;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,2BAA2B;AAC/C,sBAAsB,8BAA8B;AACpD;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,2BAA2B;AAC/C,sBAAsB,8BAA8B;AACpD;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,oBAAoB,2BAA2B;AAC/C;AACA,sBAAsB,8BAA8B;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,2BAA2B,qDAAc;AACzC;AACA;AACA,2BAA2B,sDAAe;AAC1C;AACA;AACA,2BAA2B,qDAAc;AACzC;AACA;AACA,2BAA2B,sDAAe;AAC1C;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,aAAa,qDAAc;AAC3B;AACA;AACA,aAAa,sDAAe;AAC5B;AACA;AACA,aAAa,qDAAc;AAC3B;AACA;AACA,aAAa,sDAAe;AAC5B;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;;AAEA,iEAAe,aAAa;;;;;;;;;;;;;;;;;AChThB;;AAEZ,CAAmD;;AAEnD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,iEAAe;;AAEf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,cAAc;;AAEd;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA,oBAAoB,4BAA4B;AAChD;AACA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA,oBAAoB,4BAA4B;AAChD;AACA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,4DAAqB;AAC9B;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;;;;ACzMW;;AAEZ;AACA;;AAEA,iEAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;;;;;;ACzDW;;AAEZ,CAAkC;AACqD;;AAEvF,iEAAe;AACf;AACA;AACA,2CAA2C,yDAAkB;AAC7D;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA,WAAW,yDAAkB;AAC7B;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,qBAAqB,iDAAQ,cAAc,yDAAkB,CAAC,GAAG,MAAM,GAAG,mBAAmB;AAC7F;AACA,mCAAmC,wDAAiB,EAAE,yDAAkB;AACxE;AACA,WAAW,wDAAiB;AAC5B;AACA,GAAG;;AAEH;AACA;AACA,mDAAmD,wDAAiB;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,KAAK,OAAO,KAAK;AACnE,QAAQ;AACR;AACA,yBAAyB,KAAK;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA,mDAAmD,wDAAiB;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;;;;;ACjEW;;AAEZ,CAAmG;;AAEnG,iEAAe;AACf;AACA,KAAK,2DAAY,YAAY,2DAAY;AACzC,KAAK,uDAAQ,YAAY,uDAAQ;AACjC,KAAK,6DAAc,YAAY,6DAAc;AAC7C,KAAK,2DAAY,YAAY,2DAAY;AACzC,KAAK,sDAAO,YAAY,sDAAO;AAC/B,GAAG;AACH;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;;;;;;;;;;;;ACfW;;AAEZ,CAA0I;AACxG;AACE;AACF;AACU;AACa;AACnB;AACQ;;AAE9C,iEAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,oBAAoB,qBAAqB;AACzC;AACA;AACA;AACA,oBAAoB,qDAAc,GAAG,iDAAU;AAC/C,qBAAqB,uDAAgB,GAAG,kDAAW;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,iDAAU;AACzC,gCAAgC,kDAAW;AAC3C;AACA;AACA,gCAAgC,iDAAQ;AACxC;AACA,4BAA4B,uDAAS;AACrC;AACA;AACA;AACA;AACA;AACA,2BAA2B,iDAAU;AACrC,4BAA4B,kDAAW;AACvC;AACA;AACA,4BAA4B,iDAAQ;AACpC,wBAAwB,+CAAK;AAC7B;AACA,+BAA+B,2CAAG;AAClC;;AAEA;AACA,GAAG;;AAEH;AACA;AACA,oBAAoB,sBAAsB;AAC1C;AACA;AACA;AACA,oBAAoB,iDAAU;AAC9B,qBAAqB,kDAAW;AAChC;AACA;AACA,qBAAqB,iDAAQ;AAC7B,oBAAoB,uDAAa;AACjC,6BAA6B,kEAAc;AAC3C;AACA;AACA;AACA,gCAAgC,6CAAI;AACpC;;AAEA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA,wCAAwC,qDAAc;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA,yBAAyB,4BAA4B;AACrD,yBAAyB,kCAAkC;AAC3D;AACA;AACA;AACA,GAAG;;AAEH;AACA,kCAAkC,qDAAc;AAChD,oCAAoC,uDAAgB;AACpD,mCAAmC,sDAAe;;AAElD,aAAa;AACb,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;;;;ACrLW;;AAEZ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA,iEAAe,WAAW;;;;;;;;;;;;;;;;;;AC/Bd;AACZ;AACA,CAAuC;AACkE;AACzG;AACA,iEAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,KAAK;AAChC;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oDAAa;AAC5B;AACA,yBAAyB,oDAAW;AACpC;AACA;AACA,cAAc;AACd;AACA;AACA,eAAe,qDAAc;AAC7B;AACA;AACA,eAAe,oDAAa;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,oDAAa;AAC1B;AACA;AACA,aAAa,oDAAa;AAC1B;AACA;AACA,aAAa,qDAAc;AAC3B;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,oDAAa;AACxB,qBAAqB,oDAAW;AAChC;AACA,WAAW,qDAAc;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,uBAAuB,GAAG,KAAK;AACnD;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,WAAW,qDAAc;AACzB;AACA,WAAW,oDAAa;AACxB;AACA,WAAW,oDAAa;AACxB;AACA,WAAW,oDAAa;AACxB,WAAW,qDAAc;AACzB;AACA;AACA,8DAA8D,KAAK;AACnE;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,iBAAiB,oDAAW;AAC5B;AACA;AACA,MAAM;AACN;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,CAAC;;;;;;;;;;;AC5JD;AACA;AACA;AACA;AACA;;AAEA,eAAe,mBAAO,CAAC,oEAAiB;AACxC,cAAc,mBAAO,CAAC,gEAAe;AACrC,kBAAkB,mBAAO,CAAC,wEAAmB;AAC7C,qBAAqB,mBAAO,CAAC,gFAAuB;AACpD,sBAAsB,mBAAO,CAAC,kFAAwB;AACtD,cAAc,mBAAO,CAAC,gEAAe;;AAErC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA,EAAE;AACF;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA,EAAE;AACF;AACA;AACA,EAAE;AACF;AACA;AACA,EAAE;AACF;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;AC7HA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,0BAA0B,wBAAwB;AAClD,GAAG;AACH;AACA,qBAAqB,mBAAmB;AACxC,yBAAyB,mBAAmB;AAC5C,GAAG;AACH;AACA,4BAA4B,UAAU;AACtC,GAAG;AACH;AACA,+BAA+B,UAAU;AACzC,GAAG;AACH;AACA,4BAA4B,4BAA4B;AACxD,GAAG;AACH;AACA,4BAA4B,UAAU;AACtC,GAAG;AACH;AACA,gCAAgC,sCAAsC;AACtE,GAAG;AACH;AACA,2BAA2B,UAAU;AACrC,GAAG;AACH;AACA,2BAA2B,sCAAsC;AACjE,GAAG;AACH;AACA;AACA;AACA;AACA,yBAAyB,MAAM;AAC/B,GAAG;AACH;AACA;AACA;AACA,wBAAwB,WAAW;AACnC,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA,6BAA6B,YAAY;AACzC,GAAG;AACH;AACA,gCAAgC,UAAU;AAC1C,GAAG;AACH;AACA,mCAAmC,sBAAsB;AACzD,GAAG;AACH;AACA,mCAAmC,sBAAsB;AACzD,GAAG;AACH;AACA,8BAA8B,oBAAoB;AAClD,GAAG;AACH;AACA,gCAAgC,cAAc;AAC9C,GAAG;AACH;AACA,gCAAgC,cAAc;AAC9C,GAAG;AACH;AACA,mCAAmC,sBAAsB;AACzD,GAAG;AACH;AACA,mCAAmC,uBAAuB;AAC1D,GAAG;AACH;AACA,8BAA8B,gCAAgC;AAC9D,GAAG;AACH;AACA,8BAA8B,cAAc;AAC5C,GAAG;AACH;AACA,+BAA+B,gCAAgC;AAC/D,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;AChHA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB;;AAElB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,mBAAmB;AACtC;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACzKA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,+BAA+B,8BAA8B;;AAE7D;AACA;AACA;AACA;AACA,+BAA+B,iCAAiC;AAChE;;AAEA;AACA;;AAEA;AACA;AACA,mBAAmB,mBAAmB;AACtC;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,8BAA8B;AAC/D,mBAAmB,gCAAgC;AACnD;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,mBAAmB,0BAA0B;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,0BAA0B;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,kBAAkB,yBAAyB;AAC3C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,mBAAmB;AACtC;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB,0BAA0B;AAC7C;AACA;;AAEA;AACA;AACA,mBAAmB,0BAA0B;AAC7C;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,2BAA2B;AAC7C;;AAEA;;AAEA;AACA,YAAY;AACZ;AACA,YAAY;AACZ,WAAW;AACX;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;AC3LA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,iBAAiB,mBAAO,CAAC,oEAAe;;AAExC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa;;AAEb;AACA,+BAA+B;;AAE/B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB;;AAEnB;AACA;;AAEA;AACA,iBAAiB;;AAEjB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;;AAER;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,qBAAqB;AACrB;AACA,4DAA4D;;AAE5D;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,2DAA2D,QAAQ;AACnE;AACA;AACA;;AAEA;AACA,8DAA8D;AAC9D;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,mBAAmB;AACtC;AACA;;AAEA;AACA;AACA,eAAe;;AAEf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACxfA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,wBAAwB;AACnC;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;AChFA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kEAAkE;AAClE;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA,kBAAkB,mBAAmB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,iDAAiD;AACjD,6CAA6C;;AAE7C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,4BAA4B;AAC5B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,sDAAsD;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;;AAEA;;;;;;;;;;;AC3PA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,IAAI;AACJ;AACA,EAAE;;AAEF;AACA;;AAEA;AACA;;AAEA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;UCrKA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA,IAAI;WACJ;WACA;WACA,IAAI;WACJ;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA,CAAC;WACD;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA,EAAE;WACF;WACA,sGAAsG;WACtG;WACA;WACA;WACA;WACA;WACA;WACA;WACA,GAAG;WACH;WACA;WACA;WACA;WACA;WACA,GAAG;WACH;WACA,EAAE;WACF;WACA;;;;;WChEA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;UENA;UACA;UACA;UACA","sources":["webpack:///../assets/js/constant.js","webpack:///../assets/js/game/debug.js","webpack:///../assets/js/game/game.js","webpack:///../assets/js/game/index.js","webpack:///../assets/js/model/character.js","webpack:///../assets/js/model/extra.js","webpack:///../assets/js/model/inventory.js","webpack:///../assets/js/model/link.js","webpack:///../assets/js/model/map.js","webpack:///../assets/js/model/resource/sound.js","webpack:///../assets/js/model/resource/sprite.js","webpack:///../assets/js/model/tile-transition.js","webpack:///../assets/js/model/tile.js","webpack:///../assets/js/model/top-menu.js","webpack:///../assets/js/model/transition.js","webpack:///../assets/js/resource.js","webpack:///../assets/js/service/hitbox-manager.js","webpack:///../assets/js/service/input-manager.js","webpack:///../assets/js/service/sound-manager.js","webpack:///../assets/js/service/text-manager.js","webpack:///../assets/js/service/transition-manager.js","webpack:///../assets/js/service/world-manager.js","webpack:///../assets/js/utils/compression.js","webpack:///../assets/js/utils/io.js","webpack:///../node_modules/polybooljs/index.js","webpack:///../node_modules/polybooljs/lib/build-log.js","webpack:///../node_modules/polybooljs/lib/epsilon.js","webpack:///../node_modules/polybooljs/lib/geojson.js","webpack:///../node_modules/polybooljs/lib/intersecter.js","webpack:///../node_modules/polybooljs/lib/linked-list.js","webpack:///../node_modules/polybooljs/lib/segment-chainer.js","webpack:///../node_modules/polybooljs/lib/segment-selector.js","webpack:///webpack/bootstrap","webpack:///webpack/runtime/async module","webpack:///webpack/runtime/define property getters","webpack:///webpack/runtime/hasOwnProperty shorthand","webpack:///webpack/runtime/make namespace object","webpack:///webpack/before-startup","webpack:///webpack/startup","webpack:///webpack/after-startup"],"sourcesContent":["'use strict'\n\nexport const PATH_DATA_SPRITES = 'data/sprites.loz'\nexport const PATH_DATA_SOUNDS = 'data/sounds.loz'\nexport const PATH_AUDIO_SOUNDS = 'audio/sounds.mp3'\nexport const PATH_SPRITES_IMAGE = 'images/sprites.png'\nexport const PATH_DATA_GAME = 'data/game.loz'\nexport const PATH_DATA_EMPTY_WORLD = 'data/world.empty.loz'\nexport const TILES_PATH = 'data/tiles.loz'\nexport const TILE_WIDTH = 32\nexport const TILE_HEIGHT = 32\nexport const TILES_PER_LINE = 16\nexport const TILES_PER_COLUMN = 11\nexport const WORLD_MAPS_PER_LINE = 16\nexport const WORLD_MAPS_PER_COLUMN = 8\nexport const DUNGEON_MAPS_PER_LINE = 8\nexport const DUNGEON_MAPS_PER_COLUMN = 8\nexport const EDITOR_KEYS_REDO = ['ControlLeft', 'ShiftLeft', 'KeyW']\nexport const EDITOR_KEYS_UNDO = ['ControlLeft', 'KeyW']\nexport const EDITOR_KEYS_CANCEL = ['Escape']\nexport const FILE_TYPE_JSON = 'json'\nexport const FILE_TYPE_LOZ = 'loz'\nexport const FILE_TYPE_MP3 = 'mp3'\nexport const FILE_TYPE_PNG = 'png'\nexport const FILE_TYPE_WEBP = 'webp'\nexport const GAME_INTERVAL_DRAWING = 50\nexport const GAME_INTERVAL_PROCESS = 50\nexport const GAME_INTERVAL_INPUT = 30\nexport const GAME_TOP_MENU_HEIGHT = 96\nexport const MAP_TYPE_WORLD = 'world'\nexport const MAP_TYPE_CAVERNS = 'caverns'\nexport const MAP_TYPE_LEVEL1 = 'level1'\nexport const SPRITE_WIDTH = 32\nexport const SPRITE_HEIGHT = 32\nexport const SOUND_ARROW = 'arrow'\nexport const SOUND_BOMB_BLOW = 'bomb_blow'\nexport const SOUND_BOMB_DROP = 'bomb_drop'\nexport const SOUND_BOOMERANG = 'boomerang'\nexport const SOUND_BOSS_HIT = 'boss_hit'\nexport const SOUND_BOSS_SCREAM_1 = 'boss_scream_1'\nexport const SOUND_BOSS_SCREAM_2 = 'boss_scream_2'\nexport const SOUND_BOSS_SCREAM_3 = 'boss_scream_3'\nexport const SOUND_CANDLE = 'candle'\nexport const SOUND_DOOR_UNLOCK = 'door_unlock'\nexport const SOUND_ENNEMY_DIE = 'ennemy_die'\nexport const SOUND_ENNEMY_HIT = 'ennemy_hit'\nexport const SOUND_FANFARE = 'fanfare'\nexport const SOUND_GET_HEART = 'get_heart'\nexport const SOUND_GET_ITEM = 'get_item'\nexport const SOUND_GET_RUPEE = 'get_rupee'\nexport const SOUND_KEY_APPEAR = 'key_appear'\nexport const SOUND_LINK_DIE = 'link_die'\nexport const SOUND_LINK_HURT = 'link_hurt'\nexport const SOUND_LOW_HEALTH = 'low_health'\nexport const SOUND_MAGICAL_ROD = 'magical_rod'\nexport const SOUND_OVERWORLD = 'overworld'\nexport const SOUND_RECORDER = 'recorder'\nexport const SOUND_REFILL_LOOP = 'refill_loop'\nexport const SOUND_SECRET = 'secret'\nexport const SOUND_SHIELD = 'shield'\nexport const SOUND_STAIRS = 'stairs'\nexport const SOUND_SWORD_COMBINED = 'sword_combined'\nexport const SOUND_SWORD_SHOOT = 'sword_shoot'\nexport const SOUND_SWORD_SLASH = 'sword_slash'\nexport const SOUND_TEXT = 'text'\nexport const SOUND_TEXT_LOOP = 'text_loop'\nexport const SOUND_TEXT_SLOW = 'text_slow'\nexport const SPRITE_LINK_PREFIX = 'link'\nexport const SPRITE_TEXT_PREFIX = 'text'\nexport const SPRITE_TEXT_COLOR_RED = 'red'\nexport const SPRITE_TEXT_COLOR_WHITE = 'white'\nexport const SPRITE_TEXT_WIDTH = 16\nexport const SPRITE_TEXT_HEIGHT = 16\nexport const ITEM_LADDER = 'ladder'\nexport const ITEM_MAGICAL_KEY = 'magical_key'\nexport const ITEM_POWER_BRACELET_NONE = 'power_bracelet_none'\nexport const ITEM_POWER_BRACELET_NORMAL = 'power_bracelet_normal'\nexport const ITEM_SHIELD_MAGICAL = 'magical'\nexport const ITEM_SHIELD_NORMAL = 'normal'\nexport const ITEM_RING_BLUE = 'blue'\nexport const ITEM_RING_GREEN = 'green'\nexport const ITEM_RING_RED = 'red'\nexport const ARROW_SILVER = 'arrow_silver'\nexport const ARROW_WOODEN = 'arrow_wooden'\nexport const BOOK_OF_MAGIC = 'book_of_magic'\nexport const INVENTORY_MAX_KEYS = 250\nexport const INVENTORY_MAX_RUPEES = 250\nexport const INVENTORY_MAX_BOMBS_1 = 8\nexport const INVENTORY_MAX_BOMBS_2 = 16\nexport const LINK_ACTION_MOVE = 'move'\nexport const LINK_ACTION_PICK = 'pick'\nexport const LINK_ACTION_USE = 'use'\nexport const LINK_ACTION_USE_ITEM_A = 'user_item_a'\nexport const LINK_ACTION_USE_ITEM_B = 'user_item_b'\nexport const LINK_DIRECTION_EAST = 'east'\nexport const LINK_DIRECTION_NORTH = 'north'\nexport const LINK_DIRECTION_SOUTH = 'south'\nexport const LINK_DIRECTION_WEST = 'west'\nexport const TRANSITION_MAP_EAST = 'map_east'\nexport const TRANSITION_MAP_NORTH = 'map_north'\nexport const TRANSITION_MAP_SOUTH = 'map_south'\nexport const TRANSITION_MAP_WEST = 'map_west'\nexport const TRANSITION_CAVE_ENTRANCE = 'cave_entrance'\nexport const TRANSITION_CAVE_EXIT = 'cave_exit'\nexport const TRANSITION_CAVE_STAIRS_DOWN = 'cave_stairs_down'\nexport const TRANSITION_CAVE_STAIRS_UP = 'cave_stairs_up'\nexport const TRANSITION_MAP_DRAG = 'map_drag'\nexport const TRANSITION_MAP_INCREMENT_DELTA = 8\nexport const TRANSITION_MAP_INTERVAL_PLAY = 10\nexport const DIRECTION_EAST = 'east'\nexport const DIRECTION_NORTH = 'north'\nexport const DIRECTION_SOUTH = 'south'\nexport const DIRECTION_WEST = 'west'\n","'use strict'\r\n\r\nimport { FILE_TYPE_LOZ, GAME_TOP_MENU_HEIGHT } from '../constant'\r\nimport io from '../utils/io'\r\nimport compression from '../utils/compression'\r\n\r\nclass Debug {\r\n  game\r\n  displayBlockingZones\r\n  blockingZonesColor\r\n\r\n  constructor (displayBlockingZonesCheckbox, blockingZonesColorInput, rupeesInput, rupeesSubmit, keysInput, keysSubmit, bombsInput, bombsSubmit, convertToLozInput) {\r\n    const self = this\r\n    displayBlockingZonesCheckbox.addEventListener('change', (e) => {\r\n      e.preventDefault()\r\n      self.displayBlockingZones = e.target.checked\r\n    })\r\n    displayBlockingZonesCheckbox.checked = false\r\n    displayBlockingZonesCheckbox.dispatchEvent(new Event('change'))\r\n\r\n    blockingZonesColorInput.addEventListener('change', (e) => {\r\n      e.preventDefault()\r\n      self.blockingZonesColor = e.target.value\r\n    })\r\n    blockingZonesColorInput.value = '#ff0000'\r\n    blockingZonesColorInput.dispatchEvent(new Event('change'))\r\n\r\n    rupeesSubmit.addEventListener('click', (e) => {\r\n      e.preventDefault()\r\n      self.game.link.inventory.rupees = Math.min(Math.max(rupeesInput.value, 0), self.game.link.inventory.maxRupees)\r\n      rupeesInput.value = undefined\r\n    })\r\n    keysSubmit.addEventListener('click', (e) => {\r\n      e.preventDefault()\r\n      self.game.link.inventory.keys = Math.min(Math.max(keysInput.value, 0), self.game.link.inventory.maxKeys)\r\n      keysInput.value = undefined\r\n    })\r\n    bombsSubmit.addEventListener('click', (e) => {\r\n      e.preventDefault()\r\n      self.game.link.inventory.bombs = Math.min(Math.max(bombsInput.value, 0), self.game.link.inventory.maxBombs)\r\n      bombsInput.value = undefined\r\n    })\r\n    convertToLozInput.addEventListener('click', async (e) => {\r\n      e.preventDefault()\r\n      let data = await io.openFile()\r\n      data = JSON.stringify(data)\r\n      await io.dowloadFile(data, FILE_TYPE_LOZ)\r\n    })\r\n  }\r\n\r\n  setGame (game) {\r\n    this.game = game\r\n  }\r\n\r\n  draw (context) {\r\n    if (this.displayBlockingZones) {\r\n      this.drawBlockingZones(context, this.blockingZonesColor)\r\n    }\r\n  }\r\n\r\n  drawBlockingZones (context, color) {\r\n    const map = this.game.map\r\n    context.translate(0, GAME_TOP_MENU_HEIGHT) // Translate context for top menu\r\n    context.translate(-map.x, -map.y)\r\n    map.drawBlockingZones(context, color)\r\n    if (this.game.nextMap) {\r\n      this.game.nextMap.drawBlockingZones(context, color)\r\n    }\r\n    context.translate(map.x, map.y)\r\n    context.translate(0, -GAME_TOP_MENU_HEIGHT)\r\n  }\r\n}\r\n\r\nexport { Debug }\r\n","'use strict'\n\nimport transitionManager from '../service/transition-manager'\n// import TopMenu from 'Model/top-menu'\nimport { TopMenu } from '../model/top-menu'\n// import Link from 'Model/link'\nimport Link from '../model/link'\nimport InputManager from '../service/input-manager'\nimport HitboxManager from '../service/hitbox-manager'\n// import ItemManager from 'Manager/item'\nimport { SOUND_OVERWORLD, DIRECTION_NORTH, DIRECTION_SOUTH, DIRECTION_EAST, DIRECTION_WEST, LINK_DIRECTION_EAST, LINK_DIRECTION_NORTH, LINK_DIRECTION_SOUTH, LINK_DIRECTION_WEST, LINK_ACTION_MOVE, LINK_ACTION_USE_ITEM_A, LINK_ACTION_USE_ITEM_B, MAP_TYPE_WORLD, GAME_TOP_MENU_HEIGHT, TILE_WIDTH, TILE_HEIGHT, TILES_PER_LINE, TILES_PER_COLUMN } from '../constant'\nimport soundManager from '../service/sound-manager'\nimport resource from '../resource'\nimport worldManager from '../service/world-manager'\nimport { TileTransition } from '../model/tile-transition'\nimport { MapDrag, Dialog } from '../model/transition'\n\nclass Game {\n  constructor () {\n    const startingPosition = worldManager.findStartingPosition()\n    if (!startingPosition) {\n      throw new Error('No starting position found')\n    }\n    const map = startingPosition.map\n    const link = new Link(map.x + startingPosition.tileColumn * TILE_WIDTH, map.y + startingPosition.tileLine * TILE_HEIGHT, TILE_WIDTH, TILE_HEIGHT)\n    link.map = map\n\n    this.topMenu = new TopMenu(link)\n    // this.topMenu.initializeMap(map)\n\n    this.map = map\n    this.nextMap = undefined\n\n    this.link = link\n    this.link.addEventListener(Link.EVENT_ITEM_A_CHANGED, () => InputManager.enable(InputManager.ACTION_LINK_USE_ITEM_A))\n    this.link.addEventListener(Link.EVENT_ITEM_B_CHANGED, () => InputManager.enable(InputManager.ACTION_LINK_USE_ITEM_B))\n\n    this.isStarted = false\n    this.transitionPlaying = false\n  }\n\n  start () {\n    this.map.hitbox = HitboxManager.computeMapHitboxV2(this.map)\n    this.map.init()\n    this.link.hitbox = HitboxManager.compute(this.link)\n\n    InputManager.setMapping()\n    InputManager.startDetection()\n    InputManager.currentMappingName = InputManager.MAPPING_MAIN\n\n    this.isStarted = true\n\n    soundManager.play(resource.getSound(SOUND_OVERWORLD))\n\n    // this.link.itemA = ItemManager.create(ItemManager.WOODEN_SWORD, 0, 0)\n  }\n\n  draw (context, x, y, width, height) {\n    if (!this.isStarted) {\n      return\n    }\n\n    context.clearRect(x, y, width, height)\n\n    // Translate contexte to draw map behind top menu\n    context.translate(0, GAME_TOP_MENU_HEIGHT)\n\n    context.translate(-this.map.x, -this.map.y)\n    this.map.draw(context)\n    if (this.mapDragTransitionPlaying) {\n      this.nextMap.draw(context)\n    }\n    this.link.draw(context, 0, 0, this.getLinkActionFromInput(InputManager.getCurrentDrawingAction()))\n    context.translate(this.map.x, this.map.y)\n\n    context.translate(0, -GAME_TOP_MENU_HEIGHT)\n    this.topMenu.draw(context)\n  }\n\n  async process () {\n    if (!this.isStarted) {\n      return\n    }\n\n    if (this.transitionPlaying) {\n      return\n    }\n\n    // Process static transitions\n    if (this.map.character && !this.map.character.hasStoppedTalking()) {\n      this.transitionPlaying = true\n      this.link.resetActions()\n      const transition = new Dialog()\n      await transition.play(this.link)\n      this.transitionPlaying = false\n      return\n    }\n\n\n    // Process move transitions\n    const linkTile = HitboxManager.getLinkTile(this.map, this.link)\n    if (linkTile && linkTile !== this.link.tile) {\n      linkTile.tileTransition.enabled = true\n    }\n    this.link.tile = linkTile\n    const linkFrontTile = HitboxManager.getLinkFrontTile(this.map, this.link)\n    let tileTransition\n    if (this.link.tile && !linkFrontTile) {\n      tileTransition = this.createDynamicMapDragTileTransition()\n      this.mapDragTransitionPlaying = true\n    }\n    if (this.link.tile && linkFrontTile) {\n      tileTransition = this.link.tile.tileTransition\n    }\n    if (tileTransition && tileTransition.enabled && tileTransition.start) {\n      this.transitionPlaying = true\n      this.link.resetActions()\n      this.nextMap = tileTransition.getTargetMap()\n      this.nextMap.init()\n      const transitionStart = transitionManager.get(tileTransition.start)\n      if (transitionStart) {\n        await transitionStart.play(this.link, this.map, this.nextMap)\n      }\n      this.map.reset()\n      this.map = tileTransition.getTargetMap()\n      this.nextMap = undefined\n      this.map.hitbox = HitboxManager.computeMapHitboxV2(this.map)\n      this.link.x = tileTransition.getTargetPosition().x\n      this.link.y = tileTransition.getTargetPosition().y\n      const transitionEnd = transitionManager.get(tileTransition.end)\n      if (transitionEnd) {\n        await transitionEnd.play(this.link)\n      }\n      this.link.tile = HitboxManager.getLinkTile(this.map, this.link)\n      this.link.tile.tileTransition.enabled = false\n      this.link.map = this.map\n      this.transitionPlaying = false\n      this.mapDragTransitionPlaying = false\n      tileTransition.enabled = false\n      return\n    }\n\n    // Process link\n    this.processLinkActions()\n  }\n\n  createDynamicMapDragTileTransition () {\n    let targetMapColumn\n    let targetMapLine\n    let targetTileColumn\n    let targetTileLine\n    if (this.link.direction === DIRECTION_EAST) {\n      targetMapColumn = this.map.column + 1\n      targetMapLine = this.map.line\n      targetTileColumn = 0\n      targetTileLine = (this.link.y % (TILES_PER_COLUMN * TILE_HEIGHT)) / TILE_HEIGHT\n    }\n    if (this.link.direction === DIRECTION_NORTH) {\n      targetMapColumn = this.map.column\n      targetMapLine = this.map.line - 1\n      targetTileColumn = (this.link.x % (TILES_PER_LINE * TILE_WIDTH)) / TILE_WIDTH\n      targetTileLine = TILES_PER_COLUMN - 1\n    }\n    if (this.link.direction === DIRECTION_SOUTH) {\n      targetMapColumn = this.map.column\n      targetMapLine = this.map.line + 1\n      targetTileColumn = (this.link.x % (TILES_PER_LINE * TILE_WIDTH)) / TILE_WIDTH\n      targetTileLine = 0\n    }\n    if (this.link.direction === DIRECTION_WEST) {\n      targetMapColumn = this.map.column - 1\n      targetMapLine = this.map.line\n      targetTileColumn = TILES_PER_LINE - 1\n      targetTileLine = (this.link.y % (TILES_PER_COLUMN * TILE_HEIGHT)) / TILE_HEIGHT\n    }\n    return new TileTransition(MapDrag.name, this.map.type, targetMapColumn, targetMapLine, targetTileColumn, targetTileLine)\n  }\n\n  processLinkActions () {\n    let mustWalk = false\n    const linkMoves = [InputManager.ACTION_LINK_MOVE_EAST, InputManager.ACTION_LINK_MOVE_NORTH, InputManager.ACTION_LINK_MOVE_SOUTH, InputManager.ACTION_LINK_MOVE_WEST]\n    for (let i = 0; i < linkMoves.length; i++) {\n      if (this.link.hasAction(linkMoves[i])) {\n        mustWalk = true\n      }\n    }\n\n    if (mustWalk) {\n      this.link.startWalking()\n    } else {\n      this.link.stopWalking()\n    }\n\n    if (this.link.actions.length === 0) {\n      this.link.action = LINK_ACTION_MOVE\n    } else {\n      for (let i = 0; i < this.link.actions.length; i++) {\n        this.processAction(this.link.actions[i])\n      }\n    }\n  }\n\n  getLinkActionFromInput (inputAction) {\n    switch (inputAction) {\n      case InputManager.ACTION_LINK_MOVE_EAST:\n      case InputManager.ACTION_LINK_MOVE_NORTH:\n      case InputManager.ACTION_LINK_MOVE_SOUTH:\n      case InputManager.ACTION_LINK_MOVE_WEST:\n        return LINK_ACTION_MOVE\n      case InputManager.ACTION_LINK_USE_ITEM_A:\n        return LINK_ACTION_USE_ITEM_A\n      case InputManager.ACTION_LINK_USE_ITEM_B:\n        return LINK_ACTION_USE_ITEM_B\n      default:\n        return LINK_ACTION_MOVE\n    }\n  }\n\n  processAction (action) {\n    switch (action) {\n      case InputManager.ACTION_LINK_MOVE_EAST:\n        this.link.move(this.map, LINK_DIRECTION_EAST)\n        break\n      case InputManager.ACTION_LINK_MOVE_NORTH:\n        this.link.move(this.map, LINK_DIRECTION_NORTH)\n        break\n      case InputManager.ACTION_LINK_MOVE_SOUTH:\n        this.link.move(this.map, LINK_DIRECTION_SOUTH)\n        break\n      case InputManager.ACTION_LINK_MOVE_WEST:\n        this.link.move(this.map, LINK_DIRECTION_WEST)\n        break\n      case InputManager.ACTION_LINK_USE_ITEM_A:\n        this.link.useItemA()\n        break\n      case InputManager.ACTION_LINK_USE_ITEM_B:\n        this.link.useItemB()\n        break\n      case InputManager.ACTION_MENU_CLOSE:\n\n        break\n      case InputManager.ACTION_MENU_MOVE_BOTTOM:\n\n        break\n      case InputManager.ACTION_MENU_MOVE_LEFT:\n\n        break\n      case InputManager.ACTION_MENU_MOVE_RIGHT:\n\n        break\n      case InputManager.ACTION_MENU_MOVE_TOP:\n\n        break\n      case InputManager.ACTION_MENU_OPEN:\n\n        break\n    }\n\n    this.link.removeAction(action)\n  }\n\n  processInput () {\n    if (!this.isStarted) {\n      return\n    }\n\n    if (this.transitionPlaying) {\n      return\n    }\n\n    /* if (ItemManager.isItemPlaying()) {\n      return\n    } */\n\n    const action = InputManager.getCurrentAction()\n    if (action) {\n      this.link.addAction(action)\n    }\n  }\n}\n\nexport default Game\n","'use strict'\r\n\r\nimport Game from './game'\r\nimport { Debug } from './debug'\r\nimport io from '../utils/io'\r\nimport resource from '../resource'\r\nimport soundManager from '../service/sound-manager'\r\nimport worldManager from '../service/world-manager'\r\nimport { PATH_DATA_GAME, FILE_TYPE_LOZ, GAME_INTERVAL_PROCESS, GAME_INTERVAL_DRAWING, GAME_INTERVAL_INPUT, TILES_PER_LINE, TILES_PER_COLUMN, TILE_WIDTH, TILE_HEIGHT, GAME_TOP_MENU_HEIGHT } from '../constant'\r\n\r\nlet game\r\nlet debug\r\nlet drawInterval\r\nlet processInterval\r\nlet processInputInterval\r\nconst canvas = document.querySelector('#loz-canvas')\r\nconst context = canvas.getContext('2d')\r\n\r\ncanvas.width = TILES_PER_LINE * TILE_WIDTH\r\ncanvas.height = TILES_PER_COLUMN * TILE_HEIGHT + GAME_TOP_MENU_HEIGHT\r\ncanvas.onload = () => { canvas.focus() }\r\n\r\ndebug = new Debug(\r\n  document.querySelector('input#control-blocking-zones'),\r\n  document.querySelector('input#control-blocking-zones-color'),\r\n  document.querySelector('input#control-rupees'),\r\n  document.querySelector('input#control-rupees-submit'),\r\n  document.querySelector('input#control-keys'),\r\n  document.querySelector('input#control-keys-submit'),\r\n  document.querySelector('input#control-bombs'),\r\n  document.querySelector('input#control-bombs-submit'),\r\n  document.querySelector('input#control-convert-file-to-loz')\r\n)\r\nsoundManager.initContext()\r\nsoundManager.initEvents(document.querySelector('input#play-sounds'), document.querySelector('input#control-volume'))\r\nawait resource.loadAll()\r\n\r\nasync function loadGame (gameData) {\r\n  worldManager.createMaps(gameData)\r\n\r\n  game = new Game()\r\n  debug.setGame(game)\r\n\r\n  clearInterval(drawInterval)\r\n  drawInterval = setInterval(() => {\r\n    game.draw(context, 0, 0, canvas.width, canvas.height)\r\n    debug.draw(context, 0, 0, canvas.width, canvas.height)\r\n  }, GAME_INTERVAL_DRAWING)\r\n  clearInterval(processInterval)\r\n  processInterval = setInterval(() => game.process(), GAME_INTERVAL_PROCESS)\r\n  clearInterval(processInputInterval)\r\n  processInputInterval = setInterval(() => game.processInput(), GAME_INTERVAL_INPUT)\r\n\r\n  game.start()\r\n}\r\n\r\nconst gameData = await io.fetchRemoteFile(PATH_DATA_GAME)\r\nawait loadGame(gameData)\r\n\r\ndocument.querySelector('input#control-import-game').addEventListener('click', async (e) => {\r\n  e.preventDefault()\r\n  const gameData = await io.openFile(FILE_TYPE_LOZ)\r\n  loadGame(gameData)\r\n})\r\n","'use strict'\n\nimport { SPRITE_TEXT_COLOR_WHITE, TILE_HEIGHT, TILE_WIDTH } from '../constant'\nimport textManager from '../service/text-manager'\n\nclass Character {\n  constructor (column, line, x, y, width, height, sprite, text) {\n    this.column = column\n    this.line = line\n    this.x = x\n    this.y = y\n    this.width = width\n    this.height = height\n    this.sprite = sprite\n    this.text = text\n    this.displayedText = ''\n  }\n\n  init () {\n    this.sprite.start()\n  }\n\n  reset () {\n    this.sprite.stop()\n    this.displayedText = ''\n  }\n\n  hasStoppedTalking() {\n    return this.displayedText === this.text\n  }\n\n  draw (context) {\n    this.sprite.draw(context, this.x, this.y, this.width, this.height)\n\n    textManager.draw(context, this.text, SPRITE_TEXT_COLOR_WHITE, this.x - 4.5 * TILE_WIDTH, this.y - 1.5 * TILE_HEIGHT, 10 * TILE_WIDTH, 1.5 * TILE_HEIGHT, this.displayedText.length)\n  }\n}\n\nexport { Character }\n","'use strict'\n\nclass Extra {\n  constructor (column, line, x, y, width, height, sprite) {\n    this.column = column\n    this.line = line\n    this.x = x\n    this.y = y\n    this.width = width\n    this.height = height\n    this.sprite = sprite\n  }\n\n  init () {\n    this.sprite.start()\n  }\n\n  reset () {\n    this.sprite.stop()\n  }\n\n  draw (context) {\n    this.sprite.draw(context, this.x, this.y, this.width, this.height)\n  }\n}\n\nexport { Extra }\n","'use strict'\n\nimport { ITEM_SHIELD_NORMAL, ITEM_RING_GREEN } from '../constant'\n\nclass Inventory {\n  constructor () {\n    this.shield = ITEM_SHIELD_NORMAL\n    this.ring = ITEM_RING_GREEN\n    this.arrow = undefined\n    this.bookOfMagic = undefined\n    this.ladder = undefined\n    this.magicalKey = undefined\n    this.powerBracelet = undefined\n\n    this.rupees = 0\n    this.keys = 0\n    this.bombs = 0\n    this.maxRupees = 255\n    this.maxKeys = 8\n    this.maxBombs = 8\n  }\n}\n\nexport { Inventory }\n","'use strict'\n\nimport HitboxManager from '../service/hitbox-manager'\nimport soundManager from '../service/sound-manager'\nimport resource from '../resource'\nimport { LINK_DIRECTION_EAST, LINK_DIRECTION_NORTH, LINK_DIRECTION_SOUTH, LINK_DIRECTION_WEST, LINK_ACTION_MOVE, LINK_ACTION_PICK, LINK_ACTION_USE_ITEM_A, LINK_ACTION_USE_ITEM_B, LINK_ACTION_USE, SOUND_GET_RUPEE, SPRITE_LINK_PREFIX } from '../constant'\nimport { Inventory } from './inventory'\n\nconst EVENT_ITEM_A_CHANGED = 'item_a_changed'\nconst EVENT_ITEM_B_CHANGED = 'item_b_changed'\n\nconst SPRITE_WIDTH = 32\nconst SPRITE_HEIGHT = 32\n\nconst HITBOX_DELTA = 2\nconst SPEED = 10 // Speed depends on game processing interval\n\nclass Link extends EventTarget {\n  constructor (x, y, width, height) {\n    super()\n\n    this.x = x\n    this.y = y\n    this.width = SPRITE_WIDTH\n    this.height = SPRITE_HEIGHT\n\n    this.speed = SPEED\n    this.action = LINK_ACTION_MOVE\n    this.direction = LINK_DIRECTION_SOUTH\n    this.clipX = 0\n    this.clipY = 0\n\n    this.inventory = new Inventory()\n\n    this.totalLife = 3\n    this.currentLife = 3\n\n    this.items = []\n    this._itemA = undefined\n    this._itemB = undefined\n\n    this.actions = []\n  }\n\n  canAfford (item) {\n    return item.price === undefined || this.rupees >= item.price\n  }\n\n  buy (item) {\n    if (item.price !== undefined) {\n      let i = item.price\n      const link = this\n      const soundInteval = setInterval(() => {\n        soundManager.play(resource.getSound(SOUND_GET_RUPEE))\n      }, 200)\n      var buyInterval = setInterval(() => {\n        i--\n        link.rupees--\n        if (i === 0) {\n          clearInterval(buyInterval)\n          clearInterval(soundInteval)\n          if (link.rupees < 0) {\n            link.rupee = 0\n          }\n        }\n      }, 25)\n    }\n  }\n\n  useItemA () {\n    if (this.itemA !== undefined) {\n      this.itemA.use()\n    }\n  }\n\n  useItemB () {\n    if (this.itemB !== undefined) {\n      this.itemB.use()\n    }\n  }\n\n  getHitbox (x, y) {\n    x = x || this.x\n    y = y || this.y\n\n    return {\n      x: x + HITBOX_DELTA,\n      y: y + (this.height / 2) + HITBOX_DELTA,\n      width: this.width - 2 * HITBOX_DELTA,\n      height: (this.height / 2) - 2 * HITBOX_DELTA\n    }\n  }\n\n  move (map, direction) {\n    let targetX = this.x\n    let targetY = this.y\n    let targetHitbox\n    let collision\n\n    switch (direction) {\n      case LINK_DIRECTION_EAST:\n        this.direction = LINK_DIRECTION_EAST\n        targetX += this.speed\n        targetHitbox = HitboxManager.compute(this.getHitbox(targetX, targetY))\n        collision = HitboxManager.computeHitboxesCollision(map.hitbox, targetHitbox)\n        if (collision) {\n          targetX = HitboxManager.getMinX(collision) - this.width\n        }\n        this.x = targetX\n        break\n      case LINK_DIRECTION_NORTH:\n        this.direction = LINK_DIRECTION_NORTH\n        targetY -= this.speed\n        targetHitbox = HitboxManager.compute(this.getHitbox(targetX, targetY))\n        collision = HitboxManager.computeHitboxesCollision(map.hitbox, targetHitbox)\n        if (collision) {\n          targetY = HitboxManager.getMaxY(collision) - (this.height / 2)\n        }\n        this.y = targetY\n        break\n      case LINK_DIRECTION_SOUTH:\n        this.direction = LINK_DIRECTION_SOUTH\n        targetY += this.speed\n        targetHitbox = HitboxManager.compute(this.getHitbox(targetX, targetY))\n        collision = HitboxManager.computeHitboxesCollision(map.hitbox, targetHitbox)\n        if (collision) {\n          targetY = HitboxManager.getMinY(collision) - this.height\n        }\n        this.y = targetY\n        break\n      case LINK_DIRECTION_WEST:\n        this.direction = LINK_DIRECTION_WEST\n        targetX -= this.speed\n        targetHitbox = HitboxManager.compute(this.getHitbox(targetX, targetY))\n        collision = HitboxManager.computeHitboxesCollision(map.hitbox, targetHitbox)\n        if (collision) {\n          targetX = HitboxManager.getMaxX(collision)\n        }\n        this.x = targetX\n        break\n    }\n\n    this.hitbox = HitboxManager.compute(this)\n  }\n\n  startWalking () {\n    const sprite = resource.getSprite(`${SPRITE_LINK_PREFIX}_${this.inventory.ring}_${this.direction}_${this.inventory.shield}_${this.action}`)\n    if (!sprite) {\n      console.log(`${SPRITE_LINK_PREFIX}_${this.inventory.ring}_${this.direction}_${this.inventory.shield}_${this.action}`)\n      return\n    }\n    sprite.start()\n  }\n\n  stopWalking () {\n    const sprite = resource.getSprite(`${SPRITE_LINK_PREFIX}_${this.inventory.ring}_${this.direction}_${this.inventory.shield}_${this.action}`)\n    if (!sprite) {\n      console.log(`${SPRITE_LINK_PREFIX}_${this.inventory.ring}_${this.direction}_${this.inventory.shield}_${this.action}`)\n      return\n    }\n    sprite.stop()\n  }\n\n  drawSword (context, offsetX, offsetY) {\n    context.save()\n    const itemWidth = this.itemA.sprite.width\n    const itemHeight = this.itemA.sprite.height\n    const linkX = offsetX + this.x + this.clipX\n    const linkY = offsetY + this.y + this.clipY\n    const linkWidth = this.width - this.clipX\n    const linkHeight = this.height - this.clipY\n    context.setTransform(1, 0, 0, 1, linkX + linkWidth / 2, linkY + linkHeight / 2)\n    let deltaX = 0\n    const deltaY = -3 / 4 * linkHeight\n    if (this.direction === DIRECTION_EAST) {\n      context.rotate(90 * Math.PI / 180)\n      deltaX = 1 / 8 * linkWidth\n    }\n    if (this.direction === DIRECTION_SOUTH) {\n      context.rotate(180 * Math.PI / 180)\n    }\n    if (this.direction === DIRECTION_WEST) {\n      context.rotate(-90 * Math.PI / 180)\n      deltaX = -1 / 8 * linkWidth\n    }\n    if (this.direction === DIRECTION_NORTH) {\n    }\n    this.itemA.sprite.draw(context, 0, 0, itemWidth, itemHeight, -linkWidth / 2 + deltaX, -linkHeight / 2 + deltaY, itemWidth, itemHeight)\n    context.restore()\n  }\n\n  draw (context, offsetX, offsetY, drawingAction) {\n    if (drawingAction === LINK_ACTION_USE_ITEM_A) {\n      this.drawSword(context, offsetX, offsetY)\n    }\n\n    const spriteName = this.getSpriteName(drawingAction)\n    const sprite = resource.getSprite(spriteName)\n    if (!sprite) {\n      console.log(spriteName)\n      return\n    }\n    resource.getSprite(spriteName).draw(\n      context,\n      0, 0, this.width - this.clipX, this.height - this.clipY,\n      offsetX + this.x + this.clipX, offsetY + this.y + this.clipY, this.width - this.clipX, this.height - this.clipY\n    )\n  }\n\n  getSpriteName (action) {\n    switch (action) {\n      case LINK_ACTION_PICK:\n        return `${SPRITE_LINK_PREFIX}_${this.inventory.ring}_${LINK_ACTION_PICK}`\n      case LINK_ACTION_USE_ITEM_A:\n      case LINK_ACTION_USE_ITEM_B:\n        return `${SPRITE_LINK_PREFIX}_${this.inventory.ring}_${this.shield}_${LINK_ACTION_PICK}`\n      case LINK_ACTION_MOVE:\n        return `${SPRITE_LINK_PREFIX}_${this.inventory.ring}_${this.direction}_${this.inventory.shield}_${LINK_ACTION_MOVE}`\n    }\n  }\n\n  addItem (item) {\n    this.items.push(item)\n  }\n\n  removeItem (item) {\n    for (let i = 0; i < this.items.length; i++) {\n      if (this.items[i].constructor.name === item.name) {\n        this.items.splice(i, 1)\n      }\n    }\n  }\n\n  hasItem (item) {\n    for (let i = 0; i < this.items.length; i++) {\n      if (this.items[i].constructor.name === item.name) {\n        return true\n      }\n    }\n\n    return false\n  }\n\n  addAction (action) {\n    if (this.actions.indexOf(action) === -1) {\n      this.actions.push(action)\n    }\n  }\n\n  hasAction (action) {\n    return this.actions.indexOf(action) > -1\n  }\n\n  removeAction (action) {\n    const index = this.actions.indexOf(action)\n    if (index > -1) {\n      this.actions.splice(index, 1)\n    }\n  }\n\n  resetActions () {\n    this.actions = []\n  }\n\n  get itemA () {\n    return this._itemA\n  }\n\n  set itemA (item) {\n    this._itemA = item\n    this.dispatchEvent(new Event(EVENT_ITEM_A_CHANGED))\n  }\n\n  get itemB () {\n    return this._itemB\n  }\n\n  set itemB (item) {\n    this._itemB = item\n    this.dispatchEvent(new Event(EVENT_ITEM_B_CHANGED))\n  }\n}\n\nexport default Link\n","'use strict'\n\nclass Map {\n  constructor (column, line, x, y, width, height, type, tiles, characters, extras) {\n    this.column = column\n    this.line = line\n    this.x = x\n    this.y = y\n    this.offsetX = 0\n    this.offsetY = 0\n    this.width = width\n    this.height = height\n    this.type = type\n    this.tiles = tiles\n    this.characters = characters\n    this.extras = extras\n\n    this.savedItems = []\n    this.savedCharacters = []\n    this.mapPath = this.getMapPath()\n  }\n\n  get character() {\n    return this.characters[0]\n  }\n\n  getMapPath () {\n    const path = new Path2D()\n    path.rect(this.x, this.y, this.width, this.height)\n\n    return path\n  }\n\n  init () {\n    for (const character of this.characters) {\n      character.init()\n    }\n    for (const extra of this.extras) {\n      extra.init()\n    }\n  }\n\n  reset () {\n    for (const character of this.characters) {\n      character.reset()\n    }\n    for (const extra of this.extras) {\n      extra.reset()\n    }\n  }\n\n  draw (context) {\n    context.save()\n    context.translate(this.offsetX, this.offsetY)\n    const tileOffsetX = this.x\n    const tileOffsetY = this.y\n\n    for (const tile of this.tilesIterator()) {\n      tile.draw(context)\n    }\n\n    for (const character of this.characters) {\n      character.draw(context)\n    }\n\n    for (const extra of this.extras) {\n      extra.draw(context)\n    }\n\n    /* for (let i = 0; i < this.miscs.length; i++) {\n      this.miscs[i].draw(context, tileOffsetX, tileOffsetY)\n    }\n\n    for (let i = 0; i < this.items.length; i++) {\n      this.items[i].draw(context, tileOffsetX, tileOffsetY)\n    }\n\n    for (let i = 0; i < this.characters.length; i++) {\n      this.characters[i].draw(context, tileOffsetX, tileOffsetY)\n    } */\n    context.translate(-this.offsetX, -this.offsetY)\n    context.restore()\n  }\n\n  drawBlockingZones (context, color) {\n    context.save()\n    context.translate(this.offsetX, this.offsetY)\n    context.globalAlpha = 0.5\n    context.fillStyle = color\n    for (const tile of this.tilesIterator()) {\n      context.fill(tile.blockPath)\n    }\n    context.translate(-this.offsetX, -this.offsetY)\n    context.restore()\n  }\n\n  * tilesIterator () {\n    for (let column = 0; column < this.tiles.length; column++) {\n      for (let line = 0; line < this.tiles[column].length; line++) {\n        yield this.tiles[column][line]\n      }\n    }\n  }\n\n  getTile (column, line) {\n    return this.tiles[column] ? this.tiles[column][line] : undefined\n  }\n}\n\nexport { Map }\n","'use strict'\n\nclass Sound {\n  constructor (name, buffer, context, gain, duration, loop, loopStart, loopEnd) {\n    this.name = name\n    this.buffer = buffer\n    this.context = context\n    this.gain = gain\n    this.duration = duration\n    this.loop = loop\n    this.loopStart = loopStart\n    this.loopEnd = loopEnd\n    this.source = undefined\n  }\n\n  play () {\n    this.source = this.context.createBufferSource()\n    this.source.buffer = this.buffer\n    this.source.connect(this.gain)\n    this.source.loop = this.loop\n    this.source.loopStart = this.loopStart\n    this.source.loopEnd = this.loopEnd\n    this.source.start(0)\n  }\n\n  stop () {\n    if (this.source) {\n      this.source.stop(0)\n    }\n  }\n}\n\nexport { Sound }\n","'use strict'\n\n// TODO remove this and handle draw directly in Sprite class\nclass SpriteImage {\n  constructor (name, file, offset, width, height) {\n    this.name = name\n    this.file = file\n    this.offset = offset\n    this.width = width\n    this.height = height\n  }\n\n  draw (context, x, y, w, h, dx, dy, dw, dh) {\n    if (dx !== undefined && dy !== undefined && dw !== undefined && dh !== undefined) {\n      context.drawImage(this.file, this.offset.x + x, this.offset.y + y, w, h, dx, dy, dw, dh)\n      return\n    }\n\n    context.drawImage(this.file, this.offset.x, this.offset.y, this.width, this.height, x, y, w, h)\n  }\n}\n\nclass Sprite {\n  constructor (name, type, images) {\n    this.name = name\n    this.type = type\n    this.images = images\n\n    this.currentImageIndex = 0\n    this.incrementSpeed = 200\n    this.incrementInterval = undefined\n  }\n\n  clone () {\n    return new Sprite(this.name, this.type, this.images)\n  }\n\n  start () {\n    if (this.incrementInterval) {\n      return\n    }\n\n    const self = this\n\n    this.incrementImageIndex()\n    this.incrementInterval = setInterval(() => {\n      self.incrementImageIndex()\n    }, this.incrementSpeed)\n\n    return this\n  }\n\n  stop () {\n    clearInterval(this.incrementInterval)\n    this.incrementInterval = undefined\n\n    return this\n  }\n\n  incrementImageIndex () {\n    if (!this.images) {\n      return\n    }\n\n    this.currentImageIndex++\n    if (this.currentImageIndex >= this.images.length) {\n      this.currentImageIndex = 0\n    }\n  }\n\n  draw (context, x, y, w, h, x2, y2, w2, h2) {\n    if (!this.images || !this.images[this.currentImageIndex]) {\n      return\n    }\n\n    this.images[this.currentImageIndex].draw(context, x, y, w, h, x2, y2, w2, h2)\n  }\n\n  get width () {\n    return this.images[this.currentImageIndex]?.width\n  }\n\n  get height () {\n    return this.images[this.currentImageIndex]?.height\n  }\n}\n\nexport { Sprite, SpriteImage }\n","'use strict'\n\nimport { TILE_HEIGHT, TILE_WIDTH } from '../constant'\nimport worldManager from '../service/world-manager'\n\nclass TileTransition {\n  constructor (start, targetMapType, targetMapColumn, targetMapLine, targetTileColumn, targetTileLine, end) {\n    this.start = start\n    this.targetMapType = targetMapType\n    this.targetMapColumn = targetMapColumn\n    this.targetMapLine = targetMapLine\n    this.targetTileColumn = targetTileColumn\n    this.targetTileLine = targetTileLine\n    this.end = end\n    this.enabled = true\n  }\n\n  isEmpty () {\n    return !this.start && !this.targetMapType && !this.targetMapColumn && !this.targetMapLine && !this.targetTileColumn && !this.targetTileLine && !this.end\n  }\n\n  getTargetMap () {\n    return worldManager.getMap(this.targetMapType, this.targetMapColumn, this.targetMapLine)\n  }\n\n  getTargetPosition () {\n    return {\n      x: this.getTargetMap().x + this.targetTileColumn * TILE_WIDTH,\n      y: this.getTargetMap().y + this.targetTileLine * TILE_HEIGHT\n    }\n  }\n\n  clone () {\n    return new TileTransition(this.start, this.targetMapType, this.targetMapColumn, this.targetMapLine, this.targetTileColumn, this.targetTileLine, this.end)\n  }\n}\n\nexport { TileTransition }\n","'use strict'\n\nimport { TileTransition } from './tile-transition'\n\nclass Tile {\n  constructor (column, line, x, y, width, height, hitbox, sprite, block, desctructible, tileTransition, start) {\n    this.column = column\n    this.line = line\n    this.x = x\n    this.y = y\n    this.width = width\n    this.height = height\n    this.hitbox = hitbox\n    this.sprite = sprite\n    this.transition = undefined\n    this.tilePath = this.getTilePath()\n    this.blockPath = this.getBlockPath()\n    this.block = block\n    this.desctructible = desctructible\n    this.tileTransition = tileTransition\n    this.start = start\n  }\n\n  recomputePaths () {\n    this.tilePath = this.getTilePath()\n    this.blockPath = this.getBlockPath()\n  }\n\n  clone () {\n    return new Tile(this.column, this.line, this.x, this.y, this.width, this.height, this.hitbox, this.sprite.clone(), this.block, this.desctructible, this.tileTransition.clone())\n  }\n\n  draw (context, offsetX, offsetY) {\n    const tileOffsetX = offsetX !== undefined ? this.x + offsetX : this.x\n    const tileOffsetY = offsetY !== undefined ? this.y + offsetY : this.y\n\n    this.sprite.draw(context, tileOffsetX, tileOffsetY, this.width, this.height)\n    if (this.other) {\n      this.other.draw(context, tileOffsetX, tileOffsetY, this.width, this.height)\n    }\n  }\n\n  getTilePath () {\n    const path = new Path2D()\n    path.rect(this.x, this.y, this.width, this.height)\n\n    return path\n  }\n\n  getBlockPath () {\n    if (typeof this.hitbox !== 'string') {\n      return\n    }\n\n    const points = []\n    if (this.hitbox.charAt(0) === '1') {\n      points.push([this.x, this.y])\n    }\n    if (this.hitbox.charAt(1) === '1') {\n      points.push([this.x + this.width / 2, this.y])\n    }\n    if (this.hitbox.charAt(2) === '1') {\n      points.push([this.x + this.width, this.y])\n    }\n    if (this.hitbox.charAt(3) === '1') {\n      points.push([this.x + this.width, this.y + this.height / 2])\n    }\n    if (this.hitbox.charAt(4) === '1') {\n      points.push([this.x + this.width, this.y + this.height])\n    }\n    if (this.hitbox.charAt(5) === '1') {\n      points.push([this.x + this.width / 2, this.y + this.height])\n    }\n    if (this.hitbox.charAt(6) === '1') {\n      points.push([this.x, this.y + this.height])\n    }\n    if (this.hitbox.charAt(7) === '1') {\n      points.push([this.x, this.y + this.height / 2])\n    }\n\n    const path = new Path2D()\n    if (points[0]) {\n      path.moveTo(points[0][0], points[0][1])\n    }\n    for (let i = 1; i < points.length; i++) {\n      path.lineTo(points[i][0], points[i][1])\n    }\n\n    return path\n  }\n}\n\nexport { Tile }\n","'use strict'\n\nimport resource from '../resource'\nimport { SPRITE_TEXT_COLOR_RED, SPRITE_TEXT_COLOR_WHITE, WORLD_MAPS_PER_LINE, WORLD_MAPS_PER_COLUMN } from '../constant'\nimport textManager from '../service/text-manager'\nimport worldManager from '../service/world-manager'\n\nconst SPRITE_WIDTH = 16\nconst SPRITE_HEIGHT = 16\n\nconst MAP_WIDTH = 128\nconst MAP_HEIGTH = 64\n\nclass TopMenu {\n  constructor (link) {\n    this.link = link\n\n    this.map = undefined\n    this.mapLocationWidth = undefined\n    this.mapLocationHeight = undefined\n  }\n\n  initializeMap (map) {\n    this.map = map\n\n    /* const offsetBounds = WorldManager.getOffsetBoundsFromCategory(map.type)\n    this.mapLocationWidth = MAP_WIDTH / (offsetBounds.maxX - offsetBounds.minX + 1)\n    this.mapLocationHeight = MAP_HEIGTH / (offsetBounds.maxY - offsetBounds.minY + 1) */\n  }\n\n  draw (context) {\n    // Background\n    context.fillStyle = 'black'\n    context.fillRect(0, 0, 512, 96)\n\n    // Map\n    context.translate(16, 16)\n    context.fillStyle = 'grey'\n    context.fillRect(0, 0, MAP_WIDTH, MAP_HEIGTH)\n    const mapWidth = 128 / WORLD_MAPS_PER_LINE\n    const mapHeight = 64 / WORLD_MAPS_PER_COLUMN\n    context.fillStyle = 'green'\n    context.fillRect(this.link.map.column * mapWidth, this.link.map.line * mapHeight, mapWidth, mapHeight)\n    context.translate(-16, -16)\n\n    // Rupees\n    resource.getSprite('menu_rupee').draw(context, 160, 16, SPRITE_WIDTH, SPRITE_HEIGHT)\n    textManager.draw(context, 'x' + this.link.inventory.rupees, SPRITE_TEXT_COLOR_WHITE, 176, 16, 32, 16)\n\n    // Keys\n    resource.getSprite('menu_key').draw(context, 160, 48, SPRITE_WIDTH, SPRITE_HEIGHT)\n    textManager.draw(context, 'x' + this.link.inventory.keys, SPRITE_TEXT_COLOR_WHITE, 176, 48, 32, 16)\n\n    // Bombs\n    resource.getSprite('menu_bomb').draw(context, 160, 64, SPRITE_WIDTH, SPRITE_HEIGHT)\n    textManager.draw(context, 'x' + this.link.inventory.bombs, SPRITE_TEXT_COLOR_WHITE, 176, 64, 32, 16)\n\n    // Item B\n    resource.getSprite('menu_blue_line_corner_north_west').draw(context, 256, 16, SPRITE_WIDTH, SPRITE_HEIGHT)\n    resource.getSprite('menu_blue_line_vertical').draw(context, 256, 32, SPRITE_WIDTH, SPRITE_HEIGHT)\n    resource.getSprite('menu_blue_line_vertical').draw(context, 256, 48, SPRITE_WIDTH, SPRITE_HEIGHT)\n    resource.getSprite('menu_blue_line_corner_south_west').draw(context, 256, 64, SPRITE_WIDTH, SPRITE_HEIGHT)\n    resource.getSprite('menu_blue_line_horizontal').draw(context, 272, 64, SPRITE_WIDTH, SPRITE_HEIGHT)\n    resource.getSprite('menu_blue_line_corner_south_east').draw(context, 288, 64, SPRITE_WIDTH, SPRITE_HEIGHT)\n    resource.getSprite('menu_blue_line_vertical').draw(context, 288, 48, SPRITE_WIDTH, SPRITE_HEIGHT)\n    resource.getSprite('menu_blue_line_vertical').draw(context, 288, 32, SPRITE_WIDTH, SPRITE_HEIGHT)\n    resource.getSprite('menu_blue_line_corner_north_east').draw(context, 288, 16, SPRITE_WIDTH, SPRITE_HEIGHT)\n    textManager.draw(context, 'b', SPRITE_TEXT_COLOR_WHITE, 272, 16, 16, 16)\n    if (this.link.itemB !== undefined) {\n      this.link.itemB.draw(context, 256 + 8, 16 + 16)\n    }\n\n    // Item A\n    resource.getSprite('menu_blue_line_corner_north_west').draw(context, 256 + 48, 16, SPRITE_WIDTH, SPRITE_HEIGHT)\n    resource.getSprite('menu_blue_line_vertical').draw(context, 256 + 48, 32, SPRITE_WIDTH, SPRITE_HEIGHT)\n    resource.getSprite('menu_blue_line_vertical').draw(context, 256 + 48, 48, SPRITE_WIDTH, SPRITE_HEIGHT)\n    resource.getSprite('menu_blue_line_corner_south_west').draw(context, 256 + 48, 64, SPRITE_WIDTH, SPRITE_HEIGHT)\n    resource.getSprite('menu_blue_line_horizontal').draw(context, 272 + 48, 64, SPRITE_WIDTH, SPRITE_HEIGHT)\n    resource.getSprite('menu_blue_line_corner_south_east').draw(context, 288 + 48, 64, SPRITE_WIDTH, SPRITE_HEIGHT)\n    resource.getSprite('menu_blue_line_vertical').draw(context, 288 + 48, 48, SPRITE_WIDTH, SPRITE_HEIGHT)\n    resource.getSprite('menu_blue_line_vertical').draw(context, 288 + 48, 32, SPRITE_WIDTH, SPRITE_HEIGHT)\n    resource.getSprite('menu_blue_line_corner_north_east').draw(context, 288 + 48, 16, SPRITE_WIDTH, SPRITE_HEIGHT)\n    textManager.draw(context, 'a', SPRITE_TEXT_COLOR_WHITE, 272 + 48, 16, 16, 16)\n    if (this.link.itemA !== undefined) {\n      this.link.itemA.draw(context, 256 + 48 + 8, 16 + 16)\n    }\n\n    // Life\n    textManager.draw(context, '-life-', SPRITE_TEXT_COLOR_RED, 384, 16, 96, 16)\n    let x = 368\n    let y = 64\n    for (let i = 0; i < this.link.totalLife; i++) {\n      if (i < Math.floor(this.link.currentLife + 0.25)) {\n        resource.getSprite('menu_heart_full').draw(context, x, y, SPRITE_WIDTH, SPRITE_HEIGHT)\n      } else if (i < this.currentLife) {\n        resource.getSprite('menu_heart_half').draw(context, x, y, SPRITE_WIDTH, SPRITE_HEIGHT)\n      } else {\n        resource.getSprite('menu_heart_empty').draw(context, x, y, SPRITE_WIDTH, SPRITE_HEIGHT)\n      }\n\n      x += SPRITE_WIDTH\n      if (i === 7) {\n        y -= SPRITE_HEIGHT\n        x = 368\n      }\n    }\n  }\n}\n\nexport { TopMenu }\n","'use strict'\n\nimport soundManager from '../service/sound-manager'\nimport resource from '../resource'\nimport { SOUND_TEXT_LOOP, SOUND_OVERWORLD, DIRECTION_EAST, DIRECTION_WEST, TRANSITION_MAP_INCREMENT_DELTA, DIRECTION_SOUTH, SOUND_STAIRS, TILE_HEIGHT, TRANSITION_MAP_DRAG, TRANSITION_CAVE_ENTRANCE, TRANSITION_CAVE_EXIT, TRANSITION_CAVE_STAIRS_DOWN, TRANSITION_CAVE_STAIRS_UP, TRANSITION_MAP_INTERVAL_PLAY, DIRECTION_NORTH } from '../constant'\n\nclass CaveEntrance {\n  async play (link) {\n    return new Promise((resolve) => {\n      link.y += TILE_HEIGHT\n      const limitY = link.y - 3 * TILE_HEIGHT\n      const transitionInterval = setInterval(() => {\n        link.startWalking()\n        link.y -= 2\n        if (link.y <= limitY) {\n          clearInterval(transitionInterval)\n          link.stopWalking()\n          resolve()\n        }\n      }, 15)\n    })\n  }\n\n  static get name () {\n    return TRANSITION_CAVE_ENTRANCE\n  }\n}\n\nclass CaveExit {\n  async play (link, currentMap) {\n    return new Promise((resolve) => {\n      const transitionInterval = setInterval(() => {\n        link.startWalking()\n        link.y += 2\n        if (link.y > currentMap.y + currentMap.height) {\n          clearInterval(transitionInterval)\n          link.stopWalking()\n          resolve()\n        }\n      }, 15)\n    })\n  }\n\n  static get name () {\n    return TRANSITION_CAVE_EXIT\n  }\n}\n\nclass CaveStairsDown {\n  async play (link) {\n    return new Promise((resolve) => {\n      soundManager.stop(resource.getSound(SOUND_OVERWORLD))\n      soundManager.play(resource.getSound(SOUND_STAIRS))\n      link.direction = DIRECTION_NORTH\n      link.x = link.tile.x\n      link.y = link.tile.y\n      link.clipY = 0\n      link.startWalking()\n      const transitionInterval = setInterval(() => {\n        link.clipY++\n        if (link.clipY >= TILE_HEIGHT) {\n          clearInterval(transitionInterval)\n          link.clipY = 0\n          link.stopWalking()\n          resolve()\n        }\n      }, 30)\n    })\n  }\n\n  static get name () {\n    return TRANSITION_CAVE_STAIRS_DOWN\n  }\n}\n\nclass CaveStairsUp {\n  async play (link) {\n    return new Promise((resolve) => {\n      soundManager.play(resource.getSound(SOUND_STAIRS))\n      link.direction = DIRECTION_SOUTH\n      link.clipY = TILE_HEIGHT\n      link.startWalking()\n      const transitionInterval = setInterval(() => {\n        link.clipY--\n        if (link.clipY <= 0) {\n          clearInterval(transitionInterval)\n          link.clipY = 0\n          link.stopWalking()\n          soundManager.play(resource.getSound(SOUND_OVERWORLD))\n          resolve()\n        }\n      }, 30)\n    })\n  }\n\n  static get name () {\n    return TRANSITION_CAVE_STAIRS_UP\n  }\n}\n\nclass MapDrag {\n  async play (link, currentMap, targetMap) {\n    if (link.direction === DIRECTION_EAST) {\n      return this.playEast(link, currentMap, targetMap)\n    }\n    if (link.direction === DIRECTION_NORTH) {\n      return this.playNorth(link, currentMap, targetMap)\n    }\n    if (link.direction === DIRECTION_SOUTH) {\n      return this.playSouth(link, currentMap, targetMap)\n    }\n    if (link.direction === DIRECTION_WEST) {\n      return this.playWest(link, currentMap, targetMap)\n    }\n  }\n\n  playEast (link, currentMap, targetMap) {\n    currentMap.offsetX = 0\n    targetMap.offsetX = 0\n    link.x = currentMap.x + currentMap.width - link.width\n\n    const nbTicks = Math.round(targetMap.width / TRANSITION_MAP_INCREMENT_DELTA)\n    const linkIncrementDelta = (targetMap.width - link.width) / nbTicks\n\n    return new Promise((resolve) => {\n      const transitionInterval = setInterval(() => {\n        link.startWalking()\n        currentMap.offsetX -= TRANSITION_MAP_INCREMENT_DELTA\n        targetMap.offsetX -= TRANSITION_MAP_INCREMENT_DELTA\n        link.x -= linkIncrementDelta\n        if (currentMap.offsetX < -currentMap.width && targetMap.offsetX < -targetMap.width) {\n          clearInterval(transitionInterval)\n\n          targetMap.offsetX = 0\n          link.stopWalking()\n          link.x = targetMap.x\n          currentMap.offsetX = 0\n\n          resolve()\n        }\n      }, TRANSITION_MAP_INTERVAL_PLAY)\n    })\n  }\n\n  playNorth (link, currentMap, targetMap) {\n    currentMap.offsetY = 0\n    targetMap.offsetY = 0\n    link.y = currentMap.y\n\n    const nbTicks = Math.round(targetMap.height / TRANSITION_MAP_INCREMENT_DELTA)\n    const linkIncrementDelta = (targetMap.height - link.height) / nbTicks\n\n    return new Promise((resolve) => {\n      const transitionInterval = setInterval(() => {\n        link.startWalking()\n        currentMap.offsetY += TRANSITION_MAP_INCREMENT_DELTA\n        targetMap.offsetY += TRANSITION_MAP_INCREMENT_DELTA\n        link.y += linkIncrementDelta\n        if (currentMap.offsetY > currentMap.height && targetMap.offsetY > targetMap.height) {\n          clearInterval(transitionInterval)\n\n          targetMap.offsetY = 0\n          link.stopWalking()\n          link.y = targetMap.y + targetMap.height - link.height\n          currentMap.offsetY = 0\n\n          resolve()\n        }\n      }, TRANSITION_MAP_INTERVAL_PLAY)\n    })\n  }\n\n  playSouth (link, currentMap, targetMap) {\n    currentMap.offsetY = 0\n    targetMap.offsetY = 0\n    link.y = currentMap.y + currentMap.height - link.height\n\n    const nbTicks = Math.round(targetMap.height / TRANSITION_MAP_INCREMENT_DELTA)\n    const linkIncrementDelta = (targetMap.height - link.height) / nbTicks\n\n    return new Promise((resolve) => {\n      const transitionInterval = setInterval(() => {\n        link.startWalking()\n        currentMap.offsetY -= TRANSITION_MAP_INCREMENT_DELTA\n        targetMap.offsetY -= TRANSITION_MAP_INCREMENT_DELTA\n        link.y -= linkIncrementDelta\n        if (currentMap.offsetY < -currentMap.height && targetMap.offsetY < -targetMap.height) {\n          clearInterval(transitionInterval)\n\n          targetMap.offsetY = 0\n          link.stopWalking()\n          link.y = targetMap.y\n          currentMap.offsetY = 0\n\n          resolve()\n        }\n      }, TRANSITION_MAP_INTERVAL_PLAY)\n    })\n  }\n\n  playWest (link, currentMap, targetMap) {\n    currentMap.offsetX = 0\n    targetMap.offsetX = 0\n    link.x = currentMap.x\n\n    const nbTicks = Math.round(targetMap.width / TRANSITION_MAP_INCREMENT_DELTA)\n    const linkIncrementDelta = (targetMap.width - link.width) / nbTicks\n\n    return new Promise((resolve) => {\n      const transitionInterval = setInterval(() => {\n        link.startWalking()\n        currentMap.offsetX += TRANSITION_MAP_INCREMENT_DELTA\n        targetMap.offsetX += TRANSITION_MAP_INCREMENT_DELTA\n        link.x += linkIncrementDelta\n        if (currentMap.offsetX > currentMap.width && targetMap.offsetX > targetMap.width) {\n          clearInterval(transitionInterval)\n\n          targetMap.offsetX = 0\n          link.stopWalking()\n          link.x = targetMap.x + targetMap.width - link.width\n          currentMap.offsetX = 0\n\n          resolve()\n        }\n      }, TRANSITION_MAP_INTERVAL_PLAY)\n    })\n  }\n\n  static get name () {\n    return TRANSITION_MAP_DRAG\n  }\n}\n\nclass ItemPicking {\n  constructor () {\n    this.item = undefined\n    this.character = undefined\n  }\n\n  shouldBePlayed (map, link) {\n    for (let i = 0; i < map.items.length; i++) {\n      const item = map.items[i]\n      if (item.enabled && item.shouldBePickedBy(link) && link.canAfford(item) && item.canBePickedBy(link)) {\n        this.item = item\n        return true\n      }\n    }\n\n    for (let i = 0; i < map.characters.length; i++) {\n      const character = map.characters[i]\n      if (!character.items || !character.enabled) {\n        continue\n      }\n      for (let j = 0; j < character.items.length; j++) {\n        const item = character.items[j]\n        if (item.enabled && item.shouldBePickedBy(link) && link.canAfford(item) && item.canBePickedBy(link)) {\n          this.item = item\n          this.character = character\n          return true\n        }\n      }\n    }\n\n    return false\n  }\n\n  play (map, link) {\n    if (!this.item.pick) {\n      return new Promise((resolve) => resolve())\n    }\n\n    this.isPlaying = true\n    link.stopWalking()\n\n    const clone = this.item.clone()\n    clone.price = undefined\n    map.items.push(clone)\n    this.item.picked()\n\n    const itemSavedX = clone.x\n    const itemSavedY = clone.y\n    const itemCenterX = HitboxManager.getHorizontalCenter(clone.hitbox)\n    const itemDeltaX = itemCenterX - clone.x\n    clone.x = link.x - itemDeltaX + 4\n    clone.y = link.y - clone.height\n\n    link.action = Link.ACTION_PICK\n    link.buy(this.item)\n    this.item.pickedBy(link)\n    soundManager.play(resource.getSound(SOUND_FANFARE))\n    this.character.disappearing = true\n\n    const itemPicking = this\n    return new Promise((resolve) => {\n      const characterInterval = setInterval(() => {\n        if (itemPicking.character) {\n          itemPicking.character.visible = !itemPicking.character.visible\n        }\n      }, 1)\n\n      setTimeout(() => {\n        link.action = Link.ACTION_MOVE\n        clone.x = itemSavedX\n        clone.y = itemSavedY\n\n        map.items.pop()\n\n        clearInterval(characterInterval)\n\n        itemPicking.character.itemPicked(itemPicking.item)\n        itemPicking.isPlaying = false\n        itemPicking.item = undefined\n        itemPicking.character = undefined\n\n        resolve()\n      }, 1100)\n    })\n  }\n\n  static get NAME () {\n    return ITEM_PICKING_NAME\n  }\n}\n\nclass Dialog {\n  async play (link) {\n    let length = 0\n    soundManager.play(resource.getSound(SOUND_TEXT_LOOP))\n    return new Promise((resolve) => {\n      const transitionInterval = setInterval(() => {\n        length++\n        link.map.character.displayedText = link.map.character.text.substring(0, length)\n        if (link.map.character.displayedText === link.map.character.text) {\n          soundManager.stop(resource.getSound(SOUND_TEXT_LOOP))\n          clearInterval(transitionInterval)\n          resolve()\n        }\n      }, 50)\n    })\n  }\n\n  static get NAME () {\n    return DIALOG_NAME\n  }\n}\n\nexport { CaveEntrance, CaveExit, CaveStairsDown, CaveStairsUp, MapDrag, Dialog }\n","'use strict'\r\n\r\nimport io from './utils/io'\r\nimport soundManager from './service/sound-manager'\r\nimport { PATH_DATA_SPRITES, PATH_SPRITES_IMAGE, PATH_DATA_SOUNDS, PATH_AUDIO_SOUNDS, SPRITE_WIDTH, SPRITE_HEIGHT } from './constant'\r\nimport { Sprite, SpriteImage } from './model/resource/sprite'\r\nimport { Sound } from './model/resource/sound'\r\n\r\nconst sprites = {}\r\nconst sounds = {}\r\n\r\nexport default {\r\n  loadAll: async function () {\r\n    const resources = await io.fetchRemoteFiles(PATH_DATA_SPRITES, PATH_SPRITES_IMAGE, PATH_DATA_SOUNDS, PATH_AUDIO_SOUNDS)\r\n    const dataSprites = resources[0]\r\n    const spritesImage = resources[1]\r\n    const dataSounds = resources[2]\r\n    const audioSounds = resources[3]\r\n    this.loadSprites(dataSprites, spritesImage)\r\n    await this.loadSounds(dataSounds, audioSounds)\r\n  },\r\n  loadSprites: async function (dataSprites, spritesImage) {\r\n    if (!dataSprites || !spritesImage) {\r\n      const resources = await io.fetchRemoteFiles(PATH_DATA_SPRITES, PATH_SPRITES_IMAGE)\r\n      dataSprites = resources[0]\r\n      spritesImage = resources[1]\r\n    }\r\n    for (let i = 0; i < dataSprites.length; i++) {\r\n      const dataSprite = dataSprites[i]\r\n      const name = dataSprite.name\r\n      const type = dataSprite.type\r\n      // Several image parts for one Sprite\r\n      const images = dataSprite.offsets.map((offset) => new SpriteImage(name, spritesImage, { x: offset.x * SPRITE_WIDTH, y: offset.y * SPRITE_HEIGHT }, SPRITE_WIDTH, SPRITE_HEIGHT))\r\n      sprites[name] = new Sprite(name, type, images)\r\n    }\r\n  },\r\n  cloneSprite: (name) => {\r\n    return sprites[name] ? sprites[name].clone() : undefined\r\n  },\r\n  getSprite: (name) => {\r\n    return sprites[name]\r\n  },\r\n  loadSounds: async function (dataSounds, audioSounds) {\r\n    const context = soundManager.getContext()\r\n    const gainNode = soundManager.getGainNode()\r\n    if (!context || !gainNode) {\r\n      throw new Error('Audio context must be initialized before loading sounds')\r\n    }\r\n    if (!dataSounds || !audioSounds) {\r\n      const resources = await io.fetchRemoteFiles(PATH_DATA_SOUNDS, PATH_AUDIO_SOUNDS)\r\n      dataSounds = resources[0]\r\n      audioSounds = resources[1]\r\n    }\r\n    for (let i = 0; i < dataSounds.length; i++) {\r\n      const dataSound = dataSounds[i]\r\n      const bytes = dataSound.bytes\r\n      const offset = dataSound.offset\r\n      const arrayBuffer = audioSounds.slice(offset, offset + bytes)\r\n      const audioBuffer = await context.decodeAudioData(arrayBuffer)\r\n      const name = dataSound.name\r\n      const duration = dataSound.duration || undefined\r\n      const loop = dataSound.loop || false\r\n      const loopEnd = dataSound.loop_end || 0\r\n      const loopStart = dataSound.loop_start || 0\r\n      sounds[name] = new Sound(name, audioBuffer, context, gainNode, duration, loop, loopStart, loopEnd)\r\n    }\r\n  },\r\n  cloneSound: (name) => {\r\n    return sounds[name] ? sounds[name].clone() : undefined\r\n  },\r\n  getSound: (name) => {\r\n    return sounds[name]\r\n  }\r\n}\r\n","'use strict'\n\nimport { DIRECTION_WEST, DIRECTION_SOUTH, DIRECTION_NORTH, DIRECTION_EAST } from '../constant'\n\n// @see https://www.npmjs.com/package/polybooljs\nconst PolyBool = require('polybooljs')\n\nconst HitboxManager = {\n  getHitboxFromString: function (x, y, width, height, hitboxString) {\n    var hitbox = []\n\n    if (hitboxString.charAt(0) === '1') {\n      hitbox.push([x, y])\n    }\n    if (hitboxString.charAt(1) === '1') {\n      hitbox.push([x + width / 2, y])\n    }\n    if (hitboxString.charAt(2) === '1') {\n      hitbox.push([x + width, y])\n    }\n    if (hitboxString.charAt(3) === '1') {\n      hitbox.push([x + width, y + height / 2])\n    }\n    if (hitboxString.charAt(4) === '1') {\n      hitbox.push([x + width, y + height])\n    }\n    if (hitboxString.charAt(5) === '1') {\n      hitbox.push([x + width / 2, y + height])\n    }\n    if (hitboxString.charAt(6) === '1') {\n      hitbox.push([x, y + height])\n    }\n    if (hitboxString.charAt(7) === '1') {\n      hitbox.push([x, y + height / 2])\n    }\n\n    var hitbox = {\n      regions: [hitbox],\n      inverted: false\n    }\n\n    return PolyBool.polygon(PolyBool.segments(hitbox))\n  },\n\n  getPathFromString: function (x, y, width, height, hitboxString) {\n    const hitbox = []\n    if (hitboxString.charAt(0) === '1') {\n      hitbox.push([x, y])\n    }\n    if (hitboxString.charAt(1) === '1') {\n      hitbox.push([x + width / 2, y])\n    }\n    if (hitboxString.charAt(2) === '1') {\n      hitbox.push([x + width, y])\n    }\n    if (hitboxString.charAt(3) === '1') {\n      hitbox.push([x + width, y + height / 2])\n    }\n    if (hitboxString.charAt(4) === '1') {\n      hitbox.push([x + width, y + height])\n    }\n    if (hitboxString.charAt(5) === '1') {\n      hitbox.push([x + width / 2, y + height])\n    }\n    if (hitboxString.charAt(6) === '1') {\n      hitbox.push([x, y + height])\n    }\n    if (hitboxString.charAt(7) === '1') {\n      hitbox.push([x, y + height / 2])\n    }\n\n    const path = new Path2D()\n    if (hitbox[0]) {\n      path.moveTo(hitbox[0][0], hitbox[0][1])\n    }\n    for (let i = 1; i < hitbox.length; i++) {\n      path.lineTo(hitbox[i][0], hitbox[i][1])\n    }\n\n    return path\n  },\n\n  compute: function (object) {\n    const hitbox = {\n      regions: [[\n        [object.x, object.y],\n        [object.x + object.width, object.y],\n        [object.x + object.width, object.y + object.height],\n        [object.x, object.y + object.height]\n      ]],\n      inverted: false\n    }\n\n    return hitbox\n  },\n\n  computeMapHitbox: function (map) {\n    const hitbox = {\n      regions: [],\n      inverted: false\n    }\n\n    for (let i = 0; i < map.tiles.length; i++) {\n      if (map.tiles[i].hitbox.regions[0]) {\n        hitbox.regions.push(map.tiles[i].hitbox.regions[0])\n      }\n    }\n\n    return PolyBool.union(hitbox, { regions: [], inverted: false })\n  },\n\n  computeMapHitboxV2: function (map) {\n    const hitbox = {\n      regions: [],\n      inverted: false\n    }\n\n    for (const tile of map.tilesIterator()) {\n      if (tile.block.regions && tile.block.regions[0]) {\n        hitbox.regions.push(tile.block.regions[0])\n      }\n    }\n\n    return PolyBool.union(hitbox, { regions: [], inverted: false })\n  },\n\n  computeHitboxesCollision: function (hitobx1, hitbox2) {\n    const intersection = PolyBool.intersect(hitobx1, hitbox2)\n    if (intersection && intersection.regions && intersection.regions.length > 0) {\n      return intersection\n    }\n\n    return undefined\n  },\n\n  getMinX: function (hitbox) {\n    if (!hitbox.regions) {\n      return undefined\n    }\n\n    let x\n    for (let i = 0; i < hitbox.regions.length; i++) {\n      for (let j = 0; j < hitbox.regions[i].length; j++) {\n        if (x === undefined || x > hitbox.regions[i][j][0]) {\n          x = hitbox.regions[i][j][0]\n        }\n      }\n    }\n\n    return x\n  },\n\n  getMaxX: function (hitbox) {\n    if (!hitbox.regions) {\n      return undefined\n    }\n\n    let x\n    for (let i = 0; i < hitbox.regions.length; i++) {\n      for (let j = 0; j < hitbox.regions[i].length; j++) {\n        if (x === undefined || x < hitbox.regions[i][j][0]) {\n          x = hitbox.regions[i][j][0]\n        }\n      }\n    }\n\n    return x\n  },\n\n  getMinY: function (hitbox) {\n    if (!hitbox.regions) {\n      return undefined\n    }\n\n    let y\n    for (let i = 0; i < hitbox.regions.length; i++) {\n      for (let j = 0; j < hitbox.regions[i].length; j++) {\n        if (y === undefined || y > hitbox.regions[i][j][1]) {\n          y = hitbox.regions[i][j][1]\n        }\n      }\n    }\n\n    return y\n  },\n\n  getMaxY: function (hitbox) {\n    if (!hitbox.regions) {\n      return undefined\n    }\n\n    let y\n    for (let i = 0; i < hitbox.regions.length; i++) {\n      for (let j = 0; j < hitbox.regions[i].length; j++) {\n        if (y === undefined || y < hitbox.regions[i][j][1]) {\n          y = hitbox.regions[i][j][1]\n        }\n      }\n    }\n\n    return y\n  },\n\n  draw: function (context, hitbox, offsetX, offsetY, color) {\n    if (offsetX === undefined) {\n      offsetX = 0\n    }\n    if (offsetY === undefined) {\n      offsetY = 0\n    }\n\n    context.save()\n    context.globalAlpha = 0.5\n    context.fillStyle = color\n\n    for (let i = 0; i < hitbox.regions.length; i++) {\n      context.beginPath()\n      for (let j = 0; j < hitbox.regions[i].length; j++) {\n        if (j === 0) {\n          context.moveTo(hitbox.regions[i][j][0] + offsetX, hitbox.regions[i][j][1] + offsetY)\n          continue\n        }\n        context.lineTo(hitbox.regions[i][j][0] + offsetX, hitbox.regions[i][j][1] + offsetY)\n      }\n      context.closePath()\n      context.fill()\n    }\n\n    context.restore()\n  },\n\n  getCurrentTiles: function (map, link) {\n    const currentTiles = []\n    for (const tile of map.tilesIterator()) {\n      if (\n        (tile.x <= link.x && link.x <= tile.x + tile.width && tile.y <= link.y && link.y <= tile.y + tile.height) || // link (x,y) is in tile\n                (tile.x <= link.x + link.width && link.x + link.width <= tile.x + tile.width && tile.y <= link.y && link.y <= tile.y + tile.height) || // link (x+w,y) is in tile\n                (tile.x <= link.x + link.width && link.x + link.width <= tile.x + tile.width && tile.y <= link.y + link.height && link.y + link.height <= tile.y + tile.height) || // link (x+w,y+h) is in tile\n                (tile.x <= link.x && link.x <= tile.x + tile.width && tile.y <= link.y + link.height && link.y + link.height <= tile.y + tile.height) // link (x,y+h) is in tile\n      ) {\n        currentTiles.push(tile)\n      }\n    }\n\n    return currentTiles\n  },\n\n  getLinkTile: function (map, link) {\n    const linkCenterX = link.x + link.width / 2\n    const linkCenterY = link.y + link.height / 2\n    const delta = 2\n    for (const tile of map.tilesIterator()) {\n      if (tile.x <= linkCenterX + delta && linkCenterX <= tile.x + tile.width - delta && tile.y <= linkCenterY + delta && linkCenterY <= tile.y + tile.height - delta) {\n        return tile\n      }\n    }\n\n    return undefined\n  },\n\n  getLinkFrontTile: function (map, link) {\n    const linkTile = link.tile ?? this.getLinkTile(map, link)\n    if (!linkTile) {\n      return undefined\n    }\n    if (link.direction === DIRECTION_WEST && linkTile.x >= link.x) {\n      return map.getTile(linkTile.column - 1, linkTile.line)\n    }\n    if (link.direction === DIRECTION_NORTH && linkTile.y >= link.y) {\n      return map.getTile(linkTile.column, linkTile.line - 1)\n    }\n    if (link.direction === DIRECTION_EAST && linkTile.x + linkTile.width <= link.x + link.width) {\n      return map.getTile(linkTile.column + 1, linkTile.line)\n    }\n    if (link.direction === DIRECTION_SOUTH && linkTile.y + linkTile.height <= link.y + link.height) {\n      return map.getTile(linkTile.column, linkTile.line + 1)\n    }\n    return linkTile\n  },\n\n  getReachedMapEdge: function (map, link) {\n    if (map.x >= link.x) {\n      return DIRECTION_WEST\n    }\n    if (map.y >= link.y) {\n      return DIRECTION_NORTH\n    }\n    if (map.x + map.width <= link.x) {\n      return DIRECTION_EAST\n    }\n    if (map.y + map.height <= link.y) {\n      return DIRECTION_SOUTH\n    }\n    return undefined\n  },\n\n  getHorizontalCenter: function (hitbox) {\n    const minX = this.getMinX(hitbox)\n    const maxX = this.getMaxX(hitbox)\n\n    return minX + (maxX - minX) / 2\n  }\n}\n\nexport default HitboxManager\n","'use strict'\n\nimport { GAME_INTERVAL_PROCESS } from '../constant'\n\nconst BLOCKING_ACTION = true\nconst ENABLED = true\n\nclass Key {\n  constructor (key, action, blockingAction, enabled) {\n    this.key = key\n    this.action = action\n    this.blockingAction = blockingAction\n    this.enabled = enabled\n\n    this.pressed = false\n    this.used = false\n  }\n\n  use () {\n    this.used = true\n\n    return this.action\n  }\n\n  disable () {\n    this.enabled = false\n  }\n\n  enable () {\n    this.enabled = true\n  }\n\n  unuse () {\n    this.used = false\n\n    return this.action\n  }\n\n  press () {\n    this.pressed = true\n  }\n\n  unpress () {\n    this.pressed = false\n  }\n\n  static get BLOCKING_ACTION () {\n    return BLOCKING_ACTION\n  }\n\n  static get ENABLED () {\n    return ENABLED\n  }\n}\n\nexport default {\n\n  ACTION_LINK_MOVE_WEST: 'link_move_west',\n  ACTION_LINK_MOVE_NORTH: 'link_move_north',\n  ACTION_LINK_MOVE_EAST: 'link_move_east',\n  ACTION_LINK_MOVE_SOUTH: 'link_move_south',\n  ACTION_LINK_USE_ITEM_A: 'link_use_item_a',\n  ACTION_LINK_USE_ITEM_B: 'link_use_item_b',\n  ACTION_MENU_CLOSE: 'menu_close',\n  ACTION_MENU_MOVE_LEFT: 'menu_move_left',\n  ACTION_MENU_MOVE_TOP: 'menu_move_top',\n  ACTION_MENU_MOVE_RIGHT: 'menu_move_right',\n  ACTION_MENU_MOVE_BOTTOM: 'menu_move_bottom',\n  ACTION_MENU_OPEN: 'menu_open',\n\n  MAPPING_MAIN: 'mapping_main',\n  MAPPING_MENU: 'mapping_menu',\n\n  mappings: {},\n\n  currentMappingName: undefined,\n\n  actionKeys: [],\n\n  setMapping: function () {\n    this.mappings = []\n    this.mappings[37] = new Key(37, this.ACTION_LINK_MOVE_WEST, !Key.BLOCKING_ACTION, Key.ENABLED)\n    this.mappings[38] = new Key(38, this.ACTION_LINK_MOVE_NORTH, !Key.BLOCKING_ACTION, Key.ENABLED)\n    this.mappings[39] = new Key(39, this.ACTION_LINK_MOVE_EAST, !Key.BLOCKING_ACTION, Key.ENABLED)\n    this.mappings[40] = new Key(40, this.ACTION_LINK_MOVE_SOUTH, !Key.BLOCKING_ACTION, Key.ENABLED)\n    this.mappings[65] = new Key(65, this.ACTION_LINK_USE_ITEM_A, Key.BLOCKING_ACTION, !Key.ENABLED)\n    this.mappings[66] = new Key(66, this.ACTION_LINK_USE_ITEM_B, Key.BLOCKING_ACTION, !Key.ENABLED)\n    /* return\n        this.mappings[this.MAPPING_MAIN] = {}\n        this.mappings[this.MAPPING_MAIN][this.ACTION_LINK_MOVE_WEST] = new Key(37, true)\n        this.mappings[this.MAPPING_MAIN][this.ACTION_LINK_MOVE_NORTH] = new Key(38, true)\n        this.mappings[this.MAPPING_MAIN][this.ACTION_LINK_MOVE_EAST] = new Key(39, true)\n        this.mappings[this.MAPPING_MAIN][this.ACTION_LINK_MOVE_SOUTH] = new Key(40, true)\n        this.mappings[this.MAPPING_MAIN][this.ACTION_LINK_USE_ITEM_A] = new Key(65, true)\n        this.mappings[this.MAPPING_MAIN][this.ACTION_LINK_USE_ITEM_B] = new Key(66, true)\n        this.mappings[this.MAPPING_MAIN][this.ACTION_MENU_OPEN] = 42\n\n        this.mappings[this.MAPPING_MENU] = {}\n        this.mappings[this.MAPPING_MENU][this.ACTION_MENU_MOVE_LEFT] = 37\n        this.mappings[this.MAPPING_MENU][this.ACTION_MENU_MOVE_TOP] = 38\n        this.mappings[this.MAPPING_MENU][this.ACTION_MENU_MOVE_RIGHT] = 39\n        this.mappings[this.MAPPING_MENU][this.ACTION_MENU_MOVE_BOTTOM] = 40\n        this.mappings[this.MAPPING_MENU][this.ACTION_MENU_CLOSE] = 65 */\n  },\n\n  getCurrentDrawingAction: function () {\n    for (let i = 0; i < this.actionKeys.length; i++) {\n      if (this.actionKeys[i].blockingAction) {\n        return this.actionKeys[i].use()\n      }\n    }\n\n    return this.actionKeys[0]?.use()\n  },\n\n  getCurrentAction: function () {\n    for (let i = 0; i < this.actionKeys.length; i++) {\n      if (this.actionKeys[i].blockingAction && !this.actionKeys[i].used) {\n        return this.actionKeys[i].use()\n      }\n    }\n\n    return this.actionKeys[0] && !this.actionKeys[0].blockingAction ? this.actionKeys[0].use() : undefined\n  },\n\n  clear: function () {\n    this.actionKeys = []\n  },\n\n  getKey: function (keyNumber) {\n    return this.mappings[keyNumber]\n  },\n\n  addActionKey: function (key) {\n    this.actionKeys.unshift(key)\n  },\n\n  removeActionKey: function (key) {\n    const index = this.actionKeys.indexOf(key)\n    if (index !== -1) {\n      this.actionKeys.splice(index, 1)\n    }\n  },\n\n  triggerBlockingAction (key) {\n    if (key.blockingAction) {\n      key.disable()\n      const inputManager = this\n      setTimeout(() => {\n        inputManager.removeActionKey(key)\n        key.enable()\n      }, GAME_INTERVAL_PROCESS * 5)\n    }\n  },\n\n  handleKeyDown: function (keyNumber) {\n    const key = this.getKey(keyNumber)\n    if (!key || !key.enabled) {\n      return\n    }\n\n    if (key && !key.pressed) {\n      this.removeActionKey(key)\n      this.addActionKey(key)\n      this.triggerBlockingAction(key)\n      key.press()\n    }\n  },\n\n  handleKeyUp: function (keyNumber) {\n    const key = this.getKey(keyNumber)\n    if (!key) {\n      return\n    }\n    this.removeActionKey(key)\n    key.unuse()\n    key.unpress()\n  },\n\n  enable (action) {\n    for (const key in this.mappings) {\n      if (this.mappings[key].action === action) {\n        this.mappings[key].enable()\n      }\n    }\n  },\n\n  startDetection: function () {\n    const inputManager = this\n    document.onkeydown = function (e) {\n      inputManager.handleKeyDown(e.keyCode)\n    }\n    document.onkeyup = function (e) {\n      inputManager.handleKeyUp(e.keyCode)\n    }\n  },\n\n  stopDetection: function () {\n    document.onkeydown = undefined\n    document.onkeyup = undefined\n  }\n}\n","'use strict'\n\nlet context\nlet gainNode\n\nexport default {\n  initContext () {\n    context = new AudioContext()\n    context.suspend()\n    context.createGain = context.createGain ? context.createGain : context.createGainNode\n    gainNode = context.createGain()\n    gainNode.connect(context.destination)\n  },\n  initEvents (playSoundsCheckbox, volumeRangeInput) {\n    const self = this\n    volumeRangeInput.addEventListener('change', (e) => {\n      e.preventDefault()\n      self.updateVolume(parseInt(e.target.value) / parseInt(e.target.max))\n    })\n    volumeRangeInput.value = 50\n    volumeRangeInput.dispatchEvent(new Event('change'))\n\n    playSoundsCheckbox.addEventListener('change', (e) => {\n      if (e.target.checked) {\n        self.enable()\n      } else {\n        self.disable()\n      }\n    })\n    playSoundsCheckbox.checked = false\n    playSoundsCheckbox.dispatchEvent(new Event('change'))\n  },\n  getContext () {\n    return context\n  },\n  getGainNode () {\n    return gainNode\n  },\n  updateVolume (value) {\n    gainNode.gain.setValueAtTime(value, context.currentTime)\n  },\n  enable () {\n    context.resume()\n  },\n  disable () {\n    context.suspend()\n  },\n  play (sound) {\n    sound.play()\n    const duration = sound.duration\n    if (duration) {\n      setTimeout(() => this.stop(sound), duration * 1000)\n    }\n  },\n  stop (sound) {\n    sound.stop()\n  }\n}\n","'use strict'\n\nimport resource from '../resource'\nimport { SPRITE_TEXT_PREFIX, SPRITE_TEXT_WIDTH, SPRITE_TEXT_HEIGHT } from '../constant'\n\nexport default {\n  draw: function (context, text, color, x, y, width, height, maxLength) {\n    maxLength = maxLength === undefined ? text.length : maxLength\n    const maxNbLines = Math.floor(height / SPRITE_TEXT_HEIGHT)\n    const lines = this.splitTextIntoLines(text, width)\n    let nbDisplayedCharacters = 0\n    for (let i = 0; i < lines.length; i++) {\n      const centeredLine = this.centerLine(lines[i], width)\n      const displayedLine = centeredLine.substring(0, maxLength - nbDisplayedCharacters)\n      nbDisplayedCharacters += (displayedLine.length - 1) // Sub one to handle skipped space on line break\n      this.drawLine(context, displayedLine, color, x, y)\n      y += SPRITE_TEXT_HEIGHT\n      if ((i + 1) >= maxNbLines) {\n        break\n      }\n    }\n  },\n\n  drawLine: function (context, text, color, x, y) {\n    for (const char of text) {\n      const sprite = resource.getSprite(`${SPRITE_TEXT_PREFIX}_${color}_${char.toLowerCase()}`)\n      if (sprite) {\n        sprite.draw(context, x, y, SPRITE_TEXT_WIDTH, SPRITE_TEXT_HEIGHT)\n      }\n      x += SPRITE_TEXT_WIDTH\n    }\n  },\n\n  splitTextIntoLines: function (text, maxWidth) {\n    const textPerLine = []\n    const nbLettersPerLine = Math.floor(maxWidth / SPRITE_TEXT_WIDTH)\n    let currentLine = ''\n    const parts = text.split(' ')\n    for (const part of parts) {\n      let currentNbLetters = currentLine.length\n      if (currentNbLetters > 0) {\n        currentNbLetters += 1 // Count space\n      }\n      if (currentNbLetters + part.length <= nbLettersPerLine) {\n        currentLine += currentNbLetters > 0 ? ` ${part}` : `${part}`\n      } else {\n        textPerLine.push(currentLine)\n        currentLine = `${part}`\n      }\n    }\n    if (currentLine.length > 0) {\n      textPerLine.push(currentLine)\n    }\n    return textPerLine\n  },\n\n  centerLine: function (text, maxWidth) {\n    const nbLettersPerLine = Math.floor(maxWidth / SPRITE_TEXT_WIDTH)\n    const spacesLeft = nbLettersPerLine - text.length\n    const nbStartSpaces = Math.ceil(spacesLeft / 2)\n    const nEndSpaces = Math.floor(spacesLeft / 2)\n    text = text.padStart(text.length + nbStartSpaces, ' ')\n    text = text.padEnd(text.length + nEndSpaces, ' ')\n    return text\n  }\n}\n","'use strict'\n\nimport { CaveEntrance, CaveExit, CaveStairsDown, CaveStairsUp, MapDrag } from '../model/transition'\n\nexport default {\n  transitions: {\n    [CaveEntrance.name]: new CaveEntrance(),\n    [CaveExit.name]: new CaveExit(),\n    [CaveStairsDown.name]: new CaveStairsDown(),\n    [CaveStairsUp.name]: new CaveStairsUp(),\n    [MapDrag.name]: new MapDrag()\n  },\n  get: function (name) {\n    return this.transitions[name]\n  }\n}\n","'use strict'\n\nimport { TILES_PER_LINE, TILES_PER_COLUMN, TILE_WIDTH, TILE_HEIGHT, MAP_TYPE_WORLD, MAP_TYPE_CAVERNS, MAP_TYPE_LEVEL1 } from '../constant'\nimport { Map } from '../model/map'\nimport { Tile } from '../model/tile'\nimport resource from '../resource'\nimport HitboxManager from './hitbox-manager'\nimport { TileTransition } from '../model/tile-transition'\nimport { Extra } from '../model/extra'\nimport { Character } from '../model/character'\n\nexport default {\n  world: [],\n  caverns: [],\n  level1: [],\n  level2: [],\n  level3: [],\n  level4: [],\n  level5: [],\n  level6: [],\n  level7: [],\n  level8: [],\n  level9: [],\n\n  createMaps (data) {\n    this.world = this.createMapsForType('world', data.world)\n    this.caverns = this.createMapsForType('caverns', data.caverns)\n    this.level1 = this.createMapsForType('level1', data.level1)\n  },\n\n  createMapsForType (type, mapsData) {\n    const maps = []\n    for (let i = 0; i < mapsData.length; i++) {\n      const mapData = mapsData[i]\n      const column = mapData.x\n      const line = mapData.y\n      const width = TILES_PER_LINE * TILE_WIDTH\n      const height = TILES_PER_COLUMN * TILE_HEIGHT\n      const x = column * width\n      const y = line * height\n      const tiles = this.createMapTiles(mapData.tiles, x, y)\n      if (!maps[column]) {\n        maps[column] = []\n      }\n      const characters = []\n      for (const characteraData of mapData.characters) {\n        const characterColumn = characteraData.x\n        const characterLine = characteraData.y\n        const characterWidth = TILE_WIDTH\n        const characterHeight = TILE_HEIGHT\n        const characterX = x + characterColumn * characterWidth\n        const characterY = y + characterLine * characterHeight\n        const characterSprite = resource.getSprite(characteraData.sprite)\n        const characterText = characteraData.text\n        characters.push(new Character(characterColumn, characterLine, characterX, characterY, characterWidth, characterHeight, characterSprite, characterText))\n      }\n      const extras = []\n      for (const extraData of mapData.extras) {\n        const extraColumn = extraData.x\n        const extraLine = extraData.y\n        const extraWidth = TILE_WIDTH\n        const extraHeight = TILE_HEIGHT\n        const extraX = x + extraColumn * extraWidth\n        const extraY = y + extraLine * extraHeight\n        const extraSprite = resource.getSprite(extraData.sprite)\n        extras.push(new Extra(extraColumn, extraLine, extraX, extraY, extraWidth, extraHeight, extraSprite))\n      }\n      maps[column][line] = new Map(column, line, x, y, width, height, type, tiles, characters, extras)\n    }\n\n    return maps\n  },\n\n  createMapTiles (tilesData, offsetX, offsetY) {\n    const tiles = []\n    for (let i = 0; i < tilesData.length; i++) {\n      const tileData = tilesData[i]\n      const column = tileData.x\n      const line = tileData.y\n      const width = TILE_WIDTH\n      const height = TILE_HEIGHT\n      const x = column * width + offsetX\n      const y = line * height + offsetY\n      const sprite = resource.getSprite(tileData.sprite)\n      const block = HitboxManager.getHitboxFromString(x, y, width, height, tileData.hitbox)\n      const transition = new TileTransition(tileData.transition?.start, tileData.transition?.targetMapType, tileData.transition?.targetMapColumn, tileData.transition?.targetMapLine, tileData.transition?.targetTileColumn, tileData.transition?.targetTileLine, tileData.transition?.end)\n      if (!tiles[column]) {\n        tiles[column] = []\n      }\n      tiles[column][line] = new Tile(column, line, x, y, width, height, tileData.hitbox, sprite, block, undefined, transition, !!tileData.start)\n    }\n\n    return tiles\n  },\n\n  getMap (type, column, line) {\n    return this[type] && this[type][column] && this[type][column][line] ? this[type][column][line] : undefined\n  },\n\n  findStartingPosition () {\n    for (const map of this.mapsIterator(MAP_TYPE_WORLD)) {\n      for (const tile of map.tilesIterator()) {\n        if (tile.start) {\n          return {\n            map,\n            tileColumn: tile.column,\n            tileLine: tile.line\n          }\n        }\n      }\n    }\n  },\n\n  * mapsIterator (type) {\n    for (let column = 0; column < this[type].length; column++) {\n      for (let line = 0; line < this[type][column].length; line++) {\n        yield this[type][column][line]\n      }\n    }\n  },\n\n  exportGame () {\n    const world = this.exportMaps(MAP_TYPE_WORLD)\n    const caverns = this.exportMaps(MAP_TYPE_CAVERNS)\n    const level1 = this.exportMaps(MAP_TYPE_LEVEL1)\n\n    return { world, caverns, level1 }\n  },\n\n  exportMaps (type) {\n    const mapsData = []\n    for (const map of this.mapsIterator(type)) {\n      const mapData = {\n        x: map.column,\n        y: map.line,\n        tiles: [],\n        characters: [],\n        extras: []\n      }\n      for (const character of map.characters) {\n        mapData.characters.push({\n          x: character.column,\n          y: character.line,\n          sprite: character.sprite.name,\n          text: character.text\n        })\n      }\n      for (const extra of map.extras) {\n        mapData.extras.push({\n          x: extra.column,\n          y: extra.line,\n          sprite: extra.sprite.name\n        })\n      }\n      for (const tile of map.tilesIterator()) {\n        const tileData = {\n          x: tile.column,\n          y: tile.line,\n          hitbox: tile.hitbox,\n          sprite: tile.sprite.name\n        }\n        if (!tile.tileTransition.isEmpty()) {\n          tileData.transition = {\n            start: tile.tileTransition.start,\n            targetMapType: tile.tileTransition.targetMapType,\n            targetMapColumn: tile.tileTransition.targetMapColumn,\n            targetMapLine: tile.tileTransition.targetMapLine,\n            targetTileColumn: tile.tileTransition.targetTileColumn,\n            targetTileLine: tile.tileTransition.targetTileLine,\n            end: tile.tileTransition.end\n          }\n        }\n        if (tile.start) {\n          tileData.start = true\n        }\n        mapData.tiles.push(tileData)\n      }\n      mapsData.push(mapData)\n    }\n    return mapsData\n  }\n}\n","'use strict'\n\nconst COMPRESSION_GZIP = 'gzip'\n\nconst compression = {\n  compress: async function (str) {\n    const stream = new Blob([str]).stream()\n    const compressedStream = stream.pipeThrough(new CompressionStream(COMPRESSION_GZIP))\n    const chunks = []\n    for await (const chunk of compressedStream) {\n      chunks.push(chunk)\n    }\n    return await this.concatUint8Arrays(chunks)\n  },\n  decompress: async function (compressedBytes) {\n    const stream = new Blob([compressedBytes]).stream()\n    const decompressedStream = stream.pipeThrough(new DecompressionStream(COMPRESSION_GZIP))\n    const chunks = []\n    for await (const chunk of decompressedStream) {\n      chunks.push(chunk)\n    }\n    const stringBytes = await this.concatUint8Arrays(chunks)\n    return new TextDecoder().decode(stringBytes)\n  },\n  concatUint8Arrays: async function (uint8arrays) {\n    const blob = new Blob(uint8arrays)\n    const buffer = await blob.arrayBuffer()\n    return new Uint8Array(buffer)\n  }\n}\n\nexport default compression\n","'use strict'\r\n\r\nimport compression from './compression'\r\nimport { FILE_TYPE_JSON, FILE_TYPE_LOZ, FILE_TYPE_MP3, FILE_TYPE_PNG, FILE_TYPE_WEBP } from '../constant'\r\n\r\nexport default {\r\n  openFile: async function (type) {\r\n    const self = this\r\n    return new Promise((resolve, reject) => {\r\n      const input = document.createElement('input')\r\n      input.type = 'file'\r\n      if (type) {\r\n        input.accept = `.${type}`\r\n      }\r\n      input.style.display = 'none'\r\n      input.addEventListener('cancel', () => {\r\n        input.remove()\r\n      })\r\n      input.addEventListener('change', async () => {\r\n        const files = input.files\r\n        input.remove()\r\n        if (files.length === 1) {\r\n          resolve(await self.readFile(files[0], type))\r\n        } else {\r\n          reject()\r\n        }\r\n      })\r\n      document.body.appendChild(input)\r\n      input.click()\r\n    })\r\n  },\r\n  readFile: async function (file, type) {\r\n    if (!type) {\r\n      type = this.guessTypeFromExtension(file.name)\r\n    }\r\n    return new Promise((resolve, reject) => {\r\n      const fileReader = new FileReader()\r\n      fileReader.onload = async (e) => {\r\n        let data = e.target.result\r\n        switch (type) {\r\n          case FILE_TYPE_LOZ:\r\n            data = new Uint8Array(data)\r\n            data = await compression.decompress(data)\r\n            try {\r\n              data = JSON.parse(data)\r\n            } catch (e) {}\r\n            resolve(data)\r\n            break\r\n          case FILE_TYPE_JSON:\r\n            resolve(JSON.parse(data))\r\n            break\r\n          case FILE_TYPE_PNG:\r\n            const img = await fetch(data)\r\n            const blob = await img.blob()\r\n            resolve(createImageBitmap(blob))\r\n            break\r\n          default:\r\n            reject()\r\n        }\r\n      }\r\n      switch (type) {\r\n        case FILE_TYPE_LOZ:\r\n          fileReader.readAsArrayBuffer(file)\r\n          break\r\n        case FILE_TYPE_PNG:\r\n          fileReader.readAsDataURL(file)\r\n          break\r\n        case FILE_TYPE_JSON:\r\n        default:\r\n          fileReader.readAsText(file)\r\n      }\r\n    })\r\n  },\r\n  dowloadFile: async function (data, type) {\r\n    const filename = prompt('Filename')\r\n    if (!filename) {\r\n      return\r\n    }\r\n    switch (type) {\r\n      case FILE_TYPE_LOZ:\r\n        data = await compression.compress(data)\r\n        break\r\n      case FILE_TYPE_JSON:\r\n      default:\r\n                // nothing\r\n    }\r\n    const a = document.createElement('a')\r\n    a.style.display = 'none'\r\n    a.href = URL.createObjectURL(new Blob([data]))\r\n    a.download = `${filename.toLowerCase()}.${type}`\r\n    a.textContent = 'Download'\r\n    document.body.appendChild(a)\r\n    a.click()\r\n    document.body.removeChild(a)\r\n  },\r\n  fetchRemoteFiles: async function (/* Each argument will be loaded */) {\r\n    let paths = Array.prototype.slice.call(arguments)\r\n    if (!Array.isArray(paths)) {\r\n      paths = [paths]\r\n    }\r\n    if (paths.length === 1 && Array.isArray(paths[0])) {\r\n      paths = paths[0]\r\n    }\r\n\r\n    const promises = []\r\n    for (let i = 0; i < paths.length; i++) {\r\n      promises.push(this.fetchRemoteFile(paths[i]))\r\n    }\r\n\r\n    return Promise.all(promises)\r\n  },\r\n  fetchRemoteFile: async function (path) {\r\n    const extension = path.split('.').pop()\r\n    switch (extension) {\r\n      case FILE_TYPE_JSON:\r\n        return this.fetchJsonFile(path)\r\n      case FILE_TYPE_LOZ:\r\n        return this.fetchLozFile(path)\r\n      case FILE_TYPE_MP3:\r\n        return this.fetchAudioFile(path)\r\n      case FILE_TYPE_PNG:\r\n      case FILE_TYPE_WEBP:\r\n        return this.fetchImageFile(path)\r\n      default:\r\n        throw new Error(`IO: extension not allowed for file ${path}`)\r\n    }\r\n  },\r\n  fetchLozFile: async (path) => {\r\n    let data = await fetch(path)\r\n    data = await data.arrayBuffer()\r\n    data = new Uint8Array(data)\r\n    data = await compression.decompress(data)\r\n    try {\r\n      data = JSON.parse(data)\r\n    } catch (e) {}\r\n    return data\r\n  },\r\n  fetchJsonFile: async (path) => {\r\n    let data = await fetch(path)\r\n    data = await data.json()\r\n    return data\r\n  },\r\n  fetchImageFile: async (path) => {\r\n    let data = await fetch(path)\r\n    data = await data.blob()\r\n    data = createImageBitmap(data)\r\n    return data\r\n  },\r\n  fetchAudioFile: async (path) => {\r\n    let data = await fetch(path)\r\n    data = await data.arrayBuffer()\r\n    return data\r\n  },\r\n  guessTypeFromExtension: (filename) => {\r\n    return filename.split('.').at(-1)\r\n  }\r\n}\r\n","/*\n * @copyright 2016 Sean Connelly (@voidqk), http://syntheti.cc\n * @license MIT\n * @preserve Project Home: https://github.com/voidqk/polybooljs\n */\n\nvar BuildLog = require('./lib/build-log');\nvar Epsilon = require('./lib/epsilon');\nvar Intersecter = require('./lib/intersecter');\nvar SegmentChainer = require('./lib/segment-chainer');\nvar SegmentSelector = require('./lib/segment-selector');\nvar GeoJSON = require('./lib/geojson');\n\nvar buildLog = false;\nvar epsilon = Epsilon();\n\nvar PolyBool;\nPolyBool = {\n\t// getter/setter for buildLog\n\tbuildLog: function(bl){\n\t\tif (bl === true)\n\t\t\tbuildLog = BuildLog();\n\t\telse if (bl === false)\n\t\t\tbuildLog = false;\n\t\treturn buildLog === false ? false : buildLog.list;\n\t},\n\t// getter/setter for epsilon\n\tepsilon: function(v){\n\t\treturn epsilon.epsilon(v);\n\t},\n\n\t// core API\n\tsegments: function(poly){\n\t\tvar i = Intersecter(true, epsilon, buildLog);\n\t\tpoly.regions.forEach(i.addRegion);\n\t\treturn {\n\t\t\tsegments: i.calculate(poly.inverted),\n\t\t\tinverted: poly.inverted\n\t\t};\n\t},\n\tcombine: function(segments1, segments2){\n\t\tvar i3 = Intersecter(false, epsilon, buildLog);\n\t\treturn {\n\t\t\tcombined: i3.calculate(\n\t\t\t\tsegments1.segments, segments1.inverted,\n\t\t\t\tsegments2.segments, segments2.inverted\n\t\t\t),\n\t\t\tinverted1: segments1.inverted,\n\t\t\tinverted2: segments2.inverted\n\t\t};\n\t},\n\tselectUnion: function(combined){\n\t\treturn {\n\t\t\tsegments: SegmentSelector.union(combined.combined, buildLog),\n\t\t\tinverted: combined.inverted1 || combined.inverted2\n\t\t}\n\t},\n\tselectIntersect: function(combined){\n\t\treturn {\n\t\t\tsegments: SegmentSelector.intersect(combined.combined, buildLog),\n\t\t\tinverted: combined.inverted1 && combined.inverted2\n\t\t}\n\t},\n\tselectDifference: function(combined){\n\t\treturn {\n\t\t\tsegments: SegmentSelector.difference(combined.combined, buildLog),\n\t\t\tinverted: combined.inverted1 && !combined.inverted2\n\t\t}\n\t},\n\tselectDifferenceRev: function(combined){\n\t\treturn {\n\t\t\tsegments: SegmentSelector.differenceRev(combined.combined, buildLog),\n\t\t\tinverted: !combined.inverted1 && combined.inverted2\n\t\t}\n\t},\n\tselectXor: function(combined){\n\t\treturn {\n\t\t\tsegments: SegmentSelector.xor(combined.combined, buildLog),\n\t\t\tinverted: combined.inverted1 !== combined.inverted2\n\t\t}\n\t},\n\tpolygon: function(segments){\n\t\treturn {\n\t\t\tregions: SegmentChainer(segments.segments, epsilon, buildLog),\n\t\t\tinverted: segments.inverted\n\t\t};\n\t},\n\n\t// GeoJSON converters\n\tpolygonFromGeoJSON: function(geojson){\n\t\treturn GeoJSON.toPolygon(PolyBool, geojson);\n\t},\n\tpolygonToGeoJSON: function(poly){\n\t\treturn GeoJSON.fromPolygon(PolyBool, epsilon, poly);\n\t},\n\n\t// helper functions for common operations\n\tunion: function(poly1, poly2){\n\t\treturn operate(poly1, poly2, PolyBool.selectUnion);\n\t},\n\tintersect: function(poly1, poly2){\n\t\treturn operate(poly1, poly2, PolyBool.selectIntersect);\n\t},\n\tdifference: function(poly1, poly2){\n\t\treturn operate(poly1, poly2, PolyBool.selectDifference);\n\t},\n\tdifferenceRev: function(poly1, poly2){\n\t\treturn operate(poly1, poly2, PolyBool.selectDifferenceRev);\n\t},\n\txor: function(poly1, poly2){\n\t\treturn operate(poly1, poly2, PolyBool.selectXor);\n\t}\n};\n\nfunction operate(poly1, poly2, selector){\n\tvar seg1 = PolyBool.segments(poly1);\n\tvar seg2 = PolyBool.segments(poly2);\n\tvar comb = PolyBool.combine(seg1, seg2);\n\tvar seg3 = selector(comb);\n\treturn PolyBool.polygon(seg3);\n}\n\nif (typeof window === 'object')\n\twindow.PolyBool = PolyBool;\n\nmodule.exports = PolyBool;\n","// (c) Copyright 2016, Sean Connelly (@voidqk), http://syntheti.cc\n// MIT License\n// Project Home: https://github.com/voidqk/polybooljs\n\n//\n// used strictly for logging the processing of the algorithm... only useful if you intend on\n// looking under the covers (for pretty UI's or debugging)\n//\n\nfunction BuildLog(){\n\tvar my;\n\tvar nextSegmentId = 0;\n\tvar curVert = false;\n\n\tfunction push(type, data){\n\t\tmy.list.push({\n\t\t\ttype: type,\n\t\t\tdata: data ? JSON.parse(JSON.stringify(data)) : void 0\n\t\t});\n\t\treturn my;\n\t}\n\n\tmy = {\n\t\tlist: [],\n\t\tsegmentId: function(){\n\t\t\treturn nextSegmentId++;\n\t\t},\n\t\tcheckIntersection: function(seg1, seg2){\n\t\t\treturn push('check', { seg1: seg1, seg2: seg2 });\n\t\t},\n\t\tsegmentChop: function(seg, end){\n\t\t\tpush('div_seg', { seg: seg, pt: end });\n\t\t\treturn push('chop', { seg: seg, pt: end });\n\t\t},\n\t\tstatusRemove: function(seg){\n\t\t\treturn push('pop_seg', { seg: seg });\n\t\t},\n\t\tsegmentUpdate: function(seg){\n\t\t\treturn push('seg_update', { seg: seg });\n\t\t},\n\t\tsegmentNew: function(seg, primary){\n\t\t\treturn push('new_seg', { seg: seg, primary: primary });\n\t\t},\n\t\tsegmentRemove: function(seg){\n\t\t\treturn push('rem_seg', { seg: seg });\n\t\t},\n\t\ttempStatus: function(seg, above, below){\n\t\t\treturn push('temp_status', { seg: seg, above: above, below: below });\n\t\t},\n\t\trewind: function(seg){\n\t\t\treturn push('rewind', { seg: seg });\n\t\t},\n\t\tstatus: function(seg, above, below){\n\t\t\treturn push('status', { seg: seg, above: above, below: below });\n\t\t},\n\t\tvert: function(x){\n\t\t\tif (x === curVert)\n\t\t\t\treturn my;\n\t\t\tcurVert = x;\n\t\t\treturn push('vert', { x: x });\n\t\t},\n\t\tlog: function(data){\n\t\t\tif (typeof data !== 'string')\n\t\t\t\tdata = JSON.stringify(data, false, '  ');\n\t\t\treturn push('log', { txt: data });\n\t\t},\n\t\treset: function(){\n\t\t\treturn push('reset');\n\t\t},\n\t\tselected: function(segs){\n\t\t\treturn push('selected', { segs: segs });\n\t\t},\n\t\tchainStart: function(seg){\n\t\t\treturn push('chain_start', { seg: seg });\n\t\t},\n\t\tchainRemoveHead: function(index, pt){\n\t\t\treturn push('chain_rem_head', { index: index, pt: pt });\n\t\t},\n\t\tchainRemoveTail: function(index, pt){\n\t\t\treturn push('chain_rem_tail', { index: index, pt: pt });\n\t\t},\n\t\tchainNew: function(pt1, pt2){\n\t\t\treturn push('chain_new', { pt1: pt1, pt2: pt2 });\n\t\t},\n\t\tchainMatch: function(index){\n\t\t\treturn push('chain_match', { index: index });\n\t\t},\n\t\tchainClose: function(index){\n\t\t\treturn push('chain_close', { index: index });\n\t\t},\n\t\tchainAddHead: function(index, pt){\n\t\t\treturn push('chain_add_head', { index: index, pt: pt });\n\t\t},\n\t\tchainAddTail: function(index, pt){\n\t\t\treturn push('chain_add_tail', { index: index, pt: pt, });\n\t\t},\n\t\tchainConnect: function(index1, index2){\n\t\t\treturn push('chain_con', { index1: index1, index2: index2 });\n\t\t},\n\t\tchainReverse: function(index){\n\t\t\treturn push('chain_rev', { index: index });\n\t\t},\n\t\tchainJoin: function(index1, index2){\n\t\t\treturn push('chain_join', { index1: index1, index2: index2 });\n\t\t},\n\t\tdone: function(){\n\t\t\treturn push('done');\n\t\t}\n\t};\n\treturn my;\n}\n\nmodule.exports = BuildLog;\n","// (c) Copyright 2016, Sean Connelly (@voidqk), http://syntheti.cc\n// MIT License\n// Project Home: https://github.com/voidqk/polybooljs\n\n//\n// provides the raw computation functions that takes epsilon into account\n//\n// zero is defined to be between (-epsilon, epsilon) exclusive\n//\n\nfunction Epsilon(eps){\n\tif (typeof eps !== 'number')\n\t\teps = 0.0000000001; // sane default? sure why not\n\tvar my = {\n\t\tepsilon: function(v){\n\t\t\tif (typeof v === 'number')\n\t\t\t\teps = v;\n\t\t\treturn eps;\n\t\t},\n\t\tpointAboveOrOnLine: function(pt, left, right){\n\t\t\tvar Ax = left[0];\n\t\t\tvar Ay = left[1];\n\t\t\tvar Bx = right[0];\n\t\t\tvar By = right[1];\n\t\t\tvar Cx = pt[0];\n\t\t\tvar Cy = pt[1];\n\t\t\treturn (Bx - Ax) * (Cy - Ay) - (By - Ay) * (Cx - Ax) >= -eps;\n\t\t},\n\t\tpointBetween: function(p, left, right){\n\t\t\t// p must be collinear with left->right\n\t\t\t// returns false if p == left, p == right, or left == right\n\t\t\tvar d_py_ly = p[1] - left[1];\n\t\t\tvar d_rx_lx = right[0] - left[0];\n\t\t\tvar d_px_lx = p[0] - left[0];\n\t\t\tvar d_ry_ly = right[1] - left[1];\n\n\t\t\tvar dot = d_px_lx * d_rx_lx + d_py_ly * d_ry_ly;\n\t\t\t// if `dot` is 0, then `p` == `left` or `left` == `right` (reject)\n\t\t\t// if `dot` is less than 0, then `p` is to the left of `left` (reject)\n\t\t\tif (dot < eps)\n\t\t\t\treturn false;\n\n\t\t\tvar sqlen = d_rx_lx * d_rx_lx + d_ry_ly * d_ry_ly;\n\t\t\t// if `dot` > `sqlen`, then `p` is to the right of `right` (reject)\n\t\t\t// therefore, if `dot - sqlen` is greater than 0, then `p` is to the right of `right` (reject)\n\t\t\tif (dot - sqlen > -eps)\n\t\t\t\treturn false;\n\n\t\t\treturn true;\n\t\t},\n\t\tpointsSameX: function(p1, p2){\n\t\t\treturn Math.abs(p1[0] - p2[0]) < eps;\n\t\t},\n\t\tpointsSameY: function(p1, p2){\n\t\t\treturn Math.abs(p1[1] - p2[1]) < eps;\n\t\t},\n\t\tpointsSame: function(p1, p2){\n\t\t\treturn my.pointsSameX(p1, p2) && my.pointsSameY(p1, p2);\n\t\t},\n\t\tpointsCompare: function(p1, p2){\n\t\t\t// returns -1 if p1 is smaller, 1 if p2 is smaller, 0 if equal\n\t\t\tif (my.pointsSameX(p1, p2))\n\t\t\t\treturn my.pointsSameY(p1, p2) ? 0 : (p1[1] < p2[1] ? -1 : 1);\n\t\t\treturn p1[0] < p2[0] ? -1 : 1;\n\t\t},\n\t\tpointsCollinear: function(pt1, pt2, pt3){\n\t\t\t// does pt1->pt2->pt3 make a straight line?\n\t\t\t// essentially this is just checking to see if the slope(pt1->pt2) === slope(pt2->pt3)\n\t\t\t// if slopes are equal, then they must be collinear, because they share pt2\n\t\t\tvar dx1 = pt1[0] - pt2[0];\n\t\t\tvar dy1 = pt1[1] - pt2[1];\n\t\t\tvar dx2 = pt2[0] - pt3[0];\n\t\t\tvar dy2 = pt2[1] - pt3[1];\n\t\t\treturn Math.abs(dx1 * dy2 - dx2 * dy1) < eps;\n\t\t},\n\t\tlinesIntersect: function(a0, a1, b0, b1){\n\t\t\t// returns false if the lines are coincident (e.g., parallel or on top of each other)\n\t\t\t//\n\t\t\t// returns an object if the lines intersect:\n\t\t\t//   {\n\t\t\t//     pt: [x, y],    where the intersection point is at\n\t\t\t//     alongA: where intersection point is along A,\n\t\t\t//     alongB: where intersection point is along B\n\t\t\t//   }\n\t\t\t//\n\t\t\t//  alongA and alongB will each be one of: -2, -1, 0, 1, 2\n\t\t\t//\n\t\t\t//  with the following meaning:\n\t\t\t//\n\t\t\t//    -2   intersection point is before segment's first point\n\t\t\t//    -1   intersection point is directly on segment's first point\n\t\t\t//     0   intersection point is between segment's first and second points (exclusive)\n\t\t\t//     1   intersection point is directly on segment's second point\n\t\t\t//     2   intersection point is after segment's second point\n\t\t\tvar adx = a1[0] - a0[0];\n\t\t\tvar ady = a1[1] - a0[1];\n\t\t\tvar bdx = b1[0] - b0[0];\n\t\t\tvar bdy = b1[1] - b0[1];\n\n\t\t\tvar axb = adx * bdy - ady * bdx;\n\t\t\tif (Math.abs(axb) < eps)\n\t\t\t\treturn false; // lines are coincident\n\n\t\t\tvar dx = a0[0] - b0[0];\n\t\t\tvar dy = a0[1] - b0[1];\n\n\t\t\tvar A = (bdx * dy - bdy * dx) / axb;\n\t\t\tvar B = (adx * dy - ady * dx) / axb;\n\n\t\t\tvar ret = {\n\t\t\t\talongA: 0,\n\t\t\t\talongB: 0,\n\t\t\t\tpt: [\n\t\t\t\t\ta0[0] + A * adx,\n\t\t\t\t\ta0[1] + A * ady\n\t\t\t\t]\n\t\t\t};\n\n\t\t\t// categorize where intersection point is along A and B\n\n\t\t\tif (A <= -eps)\n\t\t\t\tret.alongA = -2;\n\t\t\telse if (A < eps)\n\t\t\t\tret.alongA = -1;\n\t\t\telse if (A - 1 <= -eps)\n\t\t\t\tret.alongA = 0;\n\t\t\telse if (A - 1 < eps)\n\t\t\t\tret.alongA = 1;\n\t\t\telse\n\t\t\t\tret.alongA = 2;\n\n\t\t\tif (B <= -eps)\n\t\t\t\tret.alongB = -2;\n\t\t\telse if (B < eps)\n\t\t\t\tret.alongB = -1;\n\t\t\telse if (B - 1 <= -eps)\n\t\t\t\tret.alongB = 0;\n\t\t\telse if (B - 1 < eps)\n\t\t\t\tret.alongB = 1;\n\t\t\telse\n\t\t\t\tret.alongB = 2;\n\n\t\t\treturn ret;\n\t\t},\n\t\tpointInsideRegion: function(pt, region){\n\t\t\tvar x = pt[0];\n\t\t\tvar y = pt[1];\n\t\t\tvar last_x = region[region.length - 1][0];\n\t\t\tvar last_y = region[region.length - 1][1];\n\t\t\tvar inside = false;\n\t\t\tfor (var i = 0; i < region.length; i++){\n\t\t\t\tvar curr_x = region[i][0];\n\t\t\t\tvar curr_y = region[i][1];\n\n\t\t\t\t// if y is between curr_y and last_y, and\n\t\t\t\t// x is to the right of the boundary created by the line\n\t\t\t\tif ((curr_y - y > eps) != (last_y - y > eps) &&\n\t\t\t\t\t(last_x - curr_x) * (y - curr_y) / (last_y - curr_y) + curr_x - x > eps)\n\t\t\t\t\tinside = !inside\n\n\t\t\t\tlast_x = curr_x;\n\t\t\t\tlast_y = curr_y;\n\t\t\t}\n\t\t\treturn inside;\n\t\t}\n\t};\n\treturn my;\n}\n\nmodule.exports = Epsilon;\n","// (c) Copyright 2017, Sean Connelly (@voidqk), http://syntheti.cc\n// MIT License\n// Project Home: https://github.com/voidqk/polybooljs\n\n//\n// convert between PolyBool polygon format and GeoJSON formats (Polygon and MultiPolygon)\n//\n\nvar GeoJSON = {\n\t// convert a GeoJSON object to a PolyBool polygon\n\ttoPolygon: function(PolyBool, geojson){\n\n\t\t// converts list of LineString's to segments\n\t\tfunction GeoPoly(coords){\n\t\t\t// check for empty coords\n\t\t\tif (coords.length <= 0)\n\t\t\t\treturn PolyBool.segments({ inverted: false, regions: [] });\n\n\t\t\t// convert LineString to segments\n\t\t\tfunction LineString(ls){\n\t\t\t\t// remove tail which should be the same as head\n\t\t\t\tvar reg = ls.slice(0, ls.length - 1);\n\t\t\t\treturn PolyBool.segments({ inverted: false, regions: [reg] });\n\t\t\t}\n\n\t\t\t// the first LineString is considered the outside\n\t\t\tvar out = LineString(coords[0]);\n\n\t\t\t// the rest of the LineStrings are considered interior holes, so subtract them from the\n\t\t\t// current result\n\t\t\tfor (var i = 1; i < coords.length; i++)\n\t\t\t\tout = PolyBool.selectDifference(PolyBool.combine(out, LineString(coords[i])));\n\n\t\t\treturn out;\n\t\t}\n\n\t\tif (geojson.type === 'Polygon'){\n\t\t\t// single polygon, so just convert it and we're done\n\t\t\treturn PolyBool.polygon(GeoPoly(geojson.coordinates));\n\t\t}\n\t\telse if (geojson.type === 'MultiPolygon'){\n\t\t\t// multiple polygons, so union all the polygons together\n\t\t\tvar out = PolyBool.segments({ inverted: false, regions: [] });\n\t\t\tfor (var i = 0; i < geojson.coordinates.length; i++)\n\t\t\t\tout = PolyBool.selectUnion(PolyBool.combine(out, GeoPoly(geojson.coordinates[i])));\n\t\t\treturn PolyBool.polygon(out);\n\t\t}\n\t\tthrow new Error('PolyBool: Cannot convert GeoJSON object to PolyBool polygon');\n\t},\n\n\t// convert a PolyBool polygon to a GeoJSON object\n\tfromPolygon: function(PolyBool, eps, poly){\n\t\t// make sure out polygon is clean\n\t\tpoly = PolyBool.polygon(PolyBool.segments(poly));\n\n\t\t// test if r1 is inside r2\n\t\tfunction regionInsideRegion(r1, r2){\n\t\t\t// we're guaranteed no lines intersect (because the polygon is clean), but a vertex\n\t\t\t// could be on the edge -- so we just average pt[0] and pt[1] to produce a point on the\n\t\t\t// edge of the first line, which cannot be on an edge\n\t\t\treturn eps.pointInsideRegion([\n\t\t\t\t(r1[0][0] + r1[1][0]) * 0.5,\n\t\t\t\t(r1[0][1] + r1[1][1]) * 0.5\n\t\t\t], r2);\n\t\t}\n\n\t\t// calculate inside heirarchy\n\t\t//\n\t\t//  _____________________   _______    roots -> A       -> F\n\t\t// |          A          | |   F   |            |          |\n\t\t// |  _______   _______  | |  ___  |            +-- B      +-- G\n\t\t// | |   B   | |   C   | | | |   | |            |   |\n\t\t// | |  ___  | |  ___  | | | |   | |            |   +-- D\n\t\t// | | | D | | | | E | | | | | G | |            |\n\t\t// | | |___| | | |___| | | | |   | |            +-- C\n\t\t// | |_______| |_______| | | |___| |                |\n\t\t// |_____________________| |_______|                +-- E\n\n\t\tfunction newNode(region){\n\t\t\treturn {\n\t\t\t\tregion: region,\n\t\t\t\tchildren: []\n\t\t\t};\n\t\t}\n\n\t\tvar roots = newNode(null);\n\n\t\tfunction addChild(root, region){\n\t\t\t// first check if we're inside any children\n\t\t\tfor (var i = 0; i < root.children.length; i++){\n\t\t\t\tvar child = root.children[i];\n\t\t\t\tif (regionInsideRegion(region, child.region)){\n\t\t\t\t\t// we are, so insert inside them instead\n\t\t\t\t\taddChild(child, region);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// not inside any children, so check to see if any children are inside us\n\t\t\tvar node = newNode(region);\n\t\t\tfor (var i = 0; i < root.children.length; i++){\n\t\t\t\tvar child = root.children[i];\n\t\t\t\tif (regionInsideRegion(child.region, region)){\n\t\t\t\t\t// oops... move the child beneath us, and remove them from root\n\t\t\t\t\tnode.children.push(child);\n\t\t\t\t\troot.children.splice(i, 1);\n\t\t\t\t\ti--;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// now we can add ourselves\n\t\t\troot.children.push(node);\n\t\t}\n\n\t\t// add all regions to the root\n\t\tfor (var i = 0; i < poly.regions.length; i++){\n\t\t\tvar region = poly.regions[i];\n\t\t\tif (region.length < 3) // regions must have at least 3 points (sanity check)\n\t\t\t\tcontinue;\n\t\t\taddChild(roots, region);\n\t\t}\n\n\t\t// with our heirarchy, we can distinguish between exterior borders, and interior holes\n\t\t// the root nodes are exterior, children are interior, children's children are exterior,\n\t\t// children's children's children are interior, etc\n\n\t\t// while we're at it, exteriors are counter-clockwise, and interiors are clockwise\n\n\t\tfunction forceWinding(region, clockwise){\n\t\t\t// first, see if we're clockwise or counter-clockwise\n\t\t\t// https://en.wikipedia.org/wiki/Shoelace_formula\n\t\t\tvar winding = 0;\n\t\t\tvar last_x = region[region.length - 1][0];\n\t\t\tvar last_y = region[region.length - 1][1];\n\t\t\tvar copy = [];\n\t\t\tfor (var i = 0; i < region.length; i++){\n\t\t\t\tvar curr_x = region[i][0];\n\t\t\t\tvar curr_y = region[i][1];\n\t\t\t\tcopy.push([curr_x, curr_y]); // create a copy while we're at it\n\t\t\t\twinding += curr_y * last_x - curr_x * last_y;\n\t\t\t\tlast_x = curr_x;\n\t\t\t\tlast_y = curr_y;\n\t\t\t}\n\t\t\t// this assumes Cartesian coordinates (Y is positive going up)\n\t\t\tvar isclockwise = winding < 0;\n\t\t\tif (isclockwise !== clockwise)\n\t\t\t\tcopy.reverse();\n\t\t\t// while we're here, the last point must be the first point...\n\t\t\tcopy.push([copy[0][0], copy[0][1]]);\n\t\t\treturn copy;\n\t\t}\n\n\t\tvar geopolys = [];\n\n\t\tfunction addExterior(node){\n\t\t\tvar poly = [forceWinding(node.region, false)];\n\t\t\tgeopolys.push(poly);\n\t\t\t// children of exteriors are interior\n\t\t\tfor (var i = 0; i < node.children.length; i++)\n\t\t\t\tpoly.push(getInterior(node.children[i]));\n\t\t}\n\n\t\tfunction getInterior(node){\n\t\t\t// children of interiors are exterior\n\t\t\tfor (var i = 0; i < node.children.length; i++)\n\t\t\t\taddExterior(node.children[i]);\n\t\t\t// return the clockwise interior\n\t\t\treturn forceWinding(node.region, true);\n\t\t}\n\n\t\t// root nodes are exterior\n\t\tfor (var i = 0; i < roots.children.length; i++)\n\t\t\taddExterior(roots.children[i]);\n\n\t\t// lastly, construct the approrpriate GeoJSON object\n\n\t\tif (geopolys.length <= 0) // empty GeoJSON Polygon\n\t\t\treturn { type: 'Polygon', coordinates: [] };\n\t\tif (geopolys.length == 1) // use a GeoJSON Polygon\n\t\t\treturn { type: 'Polygon', coordinates: geopolys[0] };\n\t\treturn { // otherwise, use a GeoJSON MultiPolygon\n\t\t\ttype: 'MultiPolygon',\n\t\t\tcoordinates: geopolys\n\t\t};\n\t}\n};\n\nmodule.exports = GeoJSON;\n","// (c) Copyright 2016, Sean Connelly (@voidqk), http://syntheti.cc\n// MIT License\n// Project Home: https://github.com/voidqk/polybooljs\n\n//\n// this is the core work-horse\n//\n\nvar LinkedList = require('./linked-list');\n\nfunction Intersecter(selfIntersection, eps, buildLog){\n\t// selfIntersection is true/false depending on the phase of the overall algorithm\n\n\t//\n\t// segment creation\n\t//\n\n\tfunction segmentNew(start, end){\n\t\treturn {\n\t\t\tid: buildLog ? buildLog.segmentId() : -1,\n\t\t\tstart: start,\n\t\t\tend: end,\n\t\t\tmyFill: {\n\t\t\t\tabove: null, // is there fill above us?\n\t\t\t\tbelow: null  // is there fill below us?\n\t\t\t},\n\t\t\totherFill: null\n\t\t};\n\t}\n\n\tfunction segmentCopy(start, end, seg){\n\t\treturn {\n\t\t\tid: buildLog ? buildLog.segmentId() : -1,\n\t\t\tstart: start,\n\t\t\tend: end,\n\t\t\tmyFill: {\n\t\t\t\tabove: seg.myFill.above,\n\t\t\t\tbelow: seg.myFill.below\n\t\t\t},\n\t\t\totherFill: null\n\t\t};\n\t}\n\n\t//\n\t// event logic\n\t//\n\n\tvar event_root = LinkedList.create();\n\n\tfunction eventCompare(p1_isStart, p1_1, p1_2, p2_isStart, p2_1, p2_2){\n\t\t// compare the selected points first\n\t\tvar comp = eps.pointsCompare(p1_1, p2_1);\n\t\tif (comp !== 0)\n\t\t\treturn comp;\n\t\t// the selected points are the same\n\n\t\tif (eps.pointsSame(p1_2, p2_2)) // if the non-selected points are the same too...\n\t\t\treturn 0; // then the segments are equal\n\n\t\tif (p1_isStart !== p2_isStart) // if one is a start and the other isn't...\n\t\t\treturn p1_isStart ? 1 : -1; // favor the one that isn't the start\n\n\t\t// otherwise, we'll have to calculate which one is below the other manually\n\t\treturn eps.pointAboveOrOnLine(p1_2,\n\t\t\tp2_isStart ? p2_1 : p2_2, // order matters\n\t\t\tp2_isStart ? p2_2 : p2_1\n\t\t) ? 1 : -1;\n\t}\n\n\tfunction eventAdd(ev, other_pt){\n\t\tevent_root.insertBefore(ev, function(here){\n\t\t\t// should ev be inserted before here?\n\t\t\tvar comp = eventCompare(\n\t\t\t\tev  .isStart, ev  .pt,      other_pt,\n\t\t\t\there.isStart, here.pt, here.other.pt\n\t\t\t);\n\t\t\treturn comp < 0;\n\t\t});\n\t}\n\n\tfunction eventAddSegmentStart(seg, primary){\n\t\tvar ev_start = LinkedList.node({\n\t\t\tisStart: true,\n\t\t\tpt: seg.start,\n\t\t\tseg: seg,\n\t\t\tprimary: primary,\n\t\t\tother: null,\n\t\t\tstatus: null\n\t\t});\n\t\teventAdd(ev_start, seg.end);\n\t\treturn ev_start;\n\t}\n\n\tfunction eventAddSegmentEnd(ev_start, seg, primary){\n\t\tvar ev_end = LinkedList.node({\n\t\t\tisStart: false,\n\t\t\tpt: seg.end,\n\t\t\tseg: seg,\n\t\t\tprimary: primary,\n\t\t\tother: ev_start,\n\t\t\tstatus: null\n\t\t});\n\t\tev_start.other = ev_end;\n\t\teventAdd(ev_end, ev_start.pt);\n\t}\n\n\tfunction eventAddSegment(seg, primary){\n\t\tvar ev_start = eventAddSegmentStart(seg, primary);\n\t\teventAddSegmentEnd(ev_start, seg, primary);\n\t\treturn ev_start;\n\t}\n\n\tfunction eventUpdateEnd(ev, end){\n\t\t// slides an end backwards\n\t\t//   (start)------------(end)    to:\n\t\t//   (start)---(end)\n\n\t\tif (buildLog)\n\t\t\tbuildLog.segmentChop(ev.seg, end);\n\n\t\tev.other.remove();\n\t\tev.seg.end = end;\n\t\tev.other.pt = end;\n\t\teventAdd(ev.other, ev.pt);\n\t}\n\n\tfunction eventDivide(ev, pt){\n\t\tvar ns = segmentCopy(pt, ev.seg.end, ev.seg);\n\t\teventUpdateEnd(ev, pt);\n\t\treturn eventAddSegment(ns, ev.primary);\n\t}\n\n\tfunction calculate(primaryPolyInverted, secondaryPolyInverted){\n\t\t// if selfIntersection is true then there is no secondary polygon, so that isn't used\n\n\t\t//\n\t\t// status logic\n\t\t//\n\n\t\tvar status_root = LinkedList.create();\n\n\t\tfunction statusCompare(ev1, ev2){\n\t\t\tvar a1 = ev1.seg.start;\n\t\t\tvar a2 = ev1.seg.end;\n\t\t\tvar b1 = ev2.seg.start;\n\t\t\tvar b2 = ev2.seg.end;\n\n\t\t\tif (eps.pointsCollinear(a1, b1, b2)){\n\t\t\t\tif (eps.pointsCollinear(a2, b1, b2))\n\t\t\t\t\treturn 1;//eventCompare(true, a1, a2, true, b1, b2);\n\t\t\t\treturn eps.pointAboveOrOnLine(a2, b1, b2) ? 1 : -1;\n\t\t\t}\n\t\t\treturn eps.pointAboveOrOnLine(a1, b1, b2) ? 1 : -1;\n\t\t}\n\n\t\tfunction statusFindSurrounding(ev){\n\t\t\treturn status_root.findTransition(function(here){\n\t\t\t\tvar comp = statusCompare(ev, here.ev);\n\t\t\t\treturn comp > 0;\n\t\t\t});\n\t\t}\n\n\t\tfunction checkIntersection(ev1, ev2){\n\t\t\t// returns the segment equal to ev1, or false if nothing equal\n\n\t\t\tvar seg1 = ev1.seg;\n\t\t\tvar seg2 = ev2.seg;\n\t\t\tvar a1 = seg1.start;\n\t\t\tvar a2 = seg1.end;\n\t\t\tvar b1 = seg2.start;\n\t\t\tvar b2 = seg2.end;\n\n\t\t\tif (buildLog)\n\t\t\t\tbuildLog.checkIntersection(seg1, seg2);\n\n\t\t\tvar i = eps.linesIntersect(a1, a2, b1, b2);\n\n\t\t\tif (i === false){\n\t\t\t\t// segments are parallel or coincident\n\n\t\t\t\t// if points aren't collinear, then the segments are parallel, so no intersections\n\t\t\t\tif (!eps.pointsCollinear(a1, a2, b1))\n\t\t\t\t\treturn false;\n\t\t\t\t// otherwise, segments are on top of each other somehow (aka coincident)\n\n\t\t\t\tif (eps.pointsSame(a1, b2) || eps.pointsSame(a2, b1))\n\t\t\t\t\treturn false; // segments touch at endpoints... no intersection\n\n\t\t\t\tvar a1_equ_b1 = eps.pointsSame(a1, b1);\n\t\t\t\tvar a2_equ_b2 = eps.pointsSame(a2, b2);\n\n\t\t\t\tif (a1_equ_b1 && a2_equ_b2)\n\t\t\t\t\treturn ev2; // segments are exactly equal\n\n\t\t\t\tvar a1_between = !a1_equ_b1 && eps.pointBetween(a1, b1, b2);\n\t\t\t\tvar a2_between = !a2_equ_b2 && eps.pointBetween(a2, b1, b2);\n\n\t\t\t\t// handy for debugging:\n\t\t\t\t// buildLog.log({\n\t\t\t\t//\ta1_equ_b1: a1_equ_b1,\n\t\t\t\t//\ta2_equ_b2: a2_equ_b2,\n\t\t\t\t//\ta1_between: a1_between,\n\t\t\t\t//\ta2_between: a2_between\n\t\t\t\t// });\n\n\t\t\t\tif (a1_equ_b1){\n\t\t\t\t\tif (a2_between){\n\t\t\t\t\t\t//  (a1)---(a2)\n\t\t\t\t\t\t//  (b1)----------(b2)\n\t\t\t\t\t\teventDivide(ev2, a2);\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\t//  (a1)----------(a2)\n\t\t\t\t\t\t//  (b1)---(b2)\n\t\t\t\t\t\teventDivide(ev1, b2);\n\t\t\t\t\t}\n\t\t\t\t\treturn ev2;\n\t\t\t\t}\n\t\t\t\telse if (a1_between){\n\t\t\t\t\tif (!a2_equ_b2){\n\t\t\t\t\t\t// make a2 equal to b2\n\t\t\t\t\t\tif (a2_between){\n\t\t\t\t\t\t\t//         (a1)---(a2)\n\t\t\t\t\t\t\t//  (b1)-----------------(b2)\n\t\t\t\t\t\t\teventDivide(ev2, a2);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t//         (a1)----------(a2)\n\t\t\t\t\t\t\t//  (b1)----------(b2)\n\t\t\t\t\t\t\teventDivide(ev1, b2);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t//         (a1)---(a2)\n\t\t\t\t\t//  (b1)----------(b2)\n\t\t\t\t\teventDivide(ev2, a1);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\t// otherwise, lines intersect at i.pt, which may or may not be between the endpoints\n\n\t\t\t\t// is A divided between its endpoints? (exclusive)\n\t\t\t\tif (i.alongA === 0){\n\t\t\t\t\tif (i.alongB === -1) // yes, at exactly b1\n\t\t\t\t\t\teventDivide(ev1, b1);\n\t\t\t\t\telse if (i.alongB === 0) // yes, somewhere between B's endpoints\n\t\t\t\t\t\teventDivide(ev1, i.pt);\n\t\t\t\t\telse if (i.alongB === 1) // yes, at exactly b2\n\t\t\t\t\t\teventDivide(ev1, b2);\n\t\t\t\t}\n\n\t\t\t\t// is B divided between its endpoints? (exclusive)\n\t\t\t\tif (i.alongB === 0){\n\t\t\t\t\tif (i.alongA === -1) // yes, at exactly a1\n\t\t\t\t\t\teventDivide(ev2, a1);\n\t\t\t\t\telse if (i.alongA === 0) // yes, somewhere between A's endpoints (exclusive)\n\t\t\t\t\t\teventDivide(ev2, i.pt);\n\t\t\t\t\telse if (i.alongA === 1) // yes, at exactly a2\n\t\t\t\t\t\teventDivide(ev2, a2);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\t//\n\t\t// main event loop\n\t\t//\n\t\tvar segments = [];\n\t\twhile (!event_root.isEmpty()){\n\t\t\tvar ev = event_root.getHead();\n\n\t\t\tif (buildLog)\n\t\t\t\tbuildLog.vert(ev.pt[0]);\n\n\t\t\tif (ev.isStart){\n\n\t\t\t\tif (buildLog)\n\t\t\t\t\tbuildLog.segmentNew(ev.seg, ev.primary);\n\n\t\t\t\tvar surrounding = statusFindSurrounding(ev);\n\t\t\t\tvar above = surrounding.before ? surrounding.before.ev : null;\n\t\t\t\tvar below = surrounding.after ? surrounding.after.ev : null;\n\n\t\t\t\tif (buildLog){\n\t\t\t\t\tbuildLog.tempStatus(\n\t\t\t\t\t\tev.seg,\n\t\t\t\t\t\tabove ? above.seg : false,\n\t\t\t\t\t\tbelow ? below.seg : false\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tfunction checkBothIntersections(){\n\t\t\t\t\tif (above){\n\t\t\t\t\t\tvar eve = checkIntersection(ev, above);\n\t\t\t\t\t\tif (eve)\n\t\t\t\t\t\t\treturn eve;\n\t\t\t\t\t}\n\t\t\t\t\tif (below)\n\t\t\t\t\t\treturn checkIntersection(ev, below);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tvar eve = checkBothIntersections();\n\t\t\t\tif (eve){\n\t\t\t\t\t// ev and eve are equal\n\t\t\t\t\t// we'll keep eve and throw away ev\n\n\t\t\t\t\t// merge ev.seg's fill information into eve.seg\n\n\t\t\t\t\tif (selfIntersection){\n\t\t\t\t\t\tvar toggle; // are we a toggling edge?\n\t\t\t\t\t\tif (ev.seg.myFill.below === null)\n\t\t\t\t\t\t\ttoggle = true;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\ttoggle = ev.seg.myFill.above !== ev.seg.myFill.below;\n\n\t\t\t\t\t\t// merge two segments that belong to the same polygon\n\t\t\t\t\t\t// think of this as sandwiching two segments together, where `eve.seg` is\n\t\t\t\t\t\t// the bottom -- this will cause the above fill flag to toggle\n\t\t\t\t\t\tif (toggle)\n\t\t\t\t\t\t\teve.seg.myFill.above = !eve.seg.myFill.above;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\t// merge two segments that belong to different polygons\n\t\t\t\t\t\t// each segment has distinct knowledge, so no special logic is needed\n\t\t\t\t\t\t// note that this can only happen once per segment in this phase, because we\n\t\t\t\t\t\t// are guaranteed that all self-intersections are gone\n\t\t\t\t\t\teve.seg.otherFill = ev.seg.myFill;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (buildLog)\n\t\t\t\t\t\tbuildLog.segmentUpdate(eve.seg);\n\n\t\t\t\t\tev.other.remove();\n\t\t\t\t\tev.remove();\n\t\t\t\t}\n\n\t\t\t\tif (event_root.getHead() !== ev){\n\t\t\t\t\t// something was inserted before us in the event queue, so loop back around and\n\t\t\t\t\t// process it before continuing\n\t\t\t\t\tif (buildLog)\n\t\t\t\t\t\tbuildLog.rewind(ev.seg);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t//\n\t\t\t\t// calculate fill flags\n\t\t\t\t//\n\t\t\t\tif (selfIntersection){\n\t\t\t\t\tvar toggle; // are we a toggling edge?\n\t\t\t\t\tif (ev.seg.myFill.below === null) // if we are a new segment...\n\t\t\t\t\t\ttoggle = true; // then we toggle\n\t\t\t\t\telse // we are a segment that has previous knowledge from a division\n\t\t\t\t\t\ttoggle = ev.seg.myFill.above !== ev.seg.myFill.below; // calculate toggle\n\n\t\t\t\t\t// next, calculate whether we are filled below us\n\t\t\t\t\tif (!below){ // if nothing is below us...\n\t\t\t\t\t\t// we are filled below us if the polygon is inverted\n\t\t\t\t\t\tev.seg.myFill.below = primaryPolyInverted;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\t// otherwise, we know the answer -- it's the same if whatever is below\n\t\t\t\t\t\t// us is filled above it\n\t\t\t\t\t\tev.seg.myFill.below = below.seg.myFill.above;\n\t\t\t\t\t}\n\n\t\t\t\t\t// since now we know if we're filled below us, we can calculate whether\n\t\t\t\t\t// we're filled above us by applying toggle to whatever is below us\n\t\t\t\t\tif (toggle)\n\t\t\t\t\t\tev.seg.myFill.above = !ev.seg.myFill.below;\n\t\t\t\t\telse\n\t\t\t\t\t\tev.seg.myFill.above = ev.seg.myFill.below;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\t// now we fill in any missing transition information, since we are all-knowing\n\t\t\t\t\t// at this point\n\n\t\t\t\t\tif (ev.seg.otherFill === null){\n\t\t\t\t\t\t// if we don't have other information, then we need to figure out if we're\n\t\t\t\t\t\t// inside the other polygon\n\t\t\t\t\t\tvar inside;\n\t\t\t\t\t\tif (!below){\n\t\t\t\t\t\t\t// if nothing is below us, then we're inside if the other polygon is\n\t\t\t\t\t\t\t// inverted\n\t\t\t\t\t\t\tinside =\n\t\t\t\t\t\t\t\tev.primary ? secondaryPolyInverted : primaryPolyInverted;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{ // otherwise, something is below us\n\t\t\t\t\t\t\t// so copy the below segment's other polygon's above\n\t\t\t\t\t\t\tif (ev.primary === below.primary)\n\t\t\t\t\t\t\t\tinside = below.seg.otherFill.above;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tinside = below.seg.myFill.above;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tev.seg.otherFill = {\n\t\t\t\t\t\t\tabove: inside,\n\t\t\t\t\t\t\tbelow: inside\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (buildLog){\n\t\t\t\t\tbuildLog.status(\n\t\t\t\t\t\tev.seg,\n\t\t\t\t\t\tabove ? above.seg : false,\n\t\t\t\t\t\tbelow ? below.seg : false\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\t// insert the status and remember it for later removal\n\t\t\t\tev.other.status = surrounding.insert(LinkedList.node({ ev: ev }));\n\t\t\t}\n\t\t\telse{\n\t\t\t\tvar st = ev.status;\n\n\t\t\t\tif (st === null){\n\t\t\t\t\tthrow new Error('PolyBool: Zero-length segment detected; your epsilon is ' +\n\t\t\t\t\t\t'probably too small or too large');\n\t\t\t\t}\n\n\t\t\t\t// removing the status will create two new adjacent edges, so we'll need to check\n\t\t\t\t// for those\n\t\t\t\tif (status_root.exists(st.prev) && status_root.exists(st.next))\n\t\t\t\t\tcheckIntersection(st.prev.ev, st.next.ev);\n\n\t\t\t\tif (buildLog)\n\t\t\t\t\tbuildLog.statusRemove(st.ev.seg);\n\n\t\t\t\t// remove the status\n\t\t\t\tst.remove();\n\n\t\t\t\t// if we've reached this point, we've calculated everything there is to know, so\n\t\t\t\t// save the segment for reporting\n\t\t\t\tif (!ev.primary){\n\t\t\t\t\t// make sure `seg.myFill` actually points to the primary polygon though\n\t\t\t\t\tvar s = ev.seg.myFill;\n\t\t\t\t\tev.seg.myFill = ev.seg.otherFill;\n\t\t\t\t\tev.seg.otherFill = s;\n\t\t\t\t}\n\t\t\t\tsegments.push(ev.seg);\n\t\t\t}\n\n\t\t\t// remove the event and continue\n\t\t\tevent_root.getHead().remove();\n\t\t}\n\n\t\tif (buildLog)\n\t\t\tbuildLog.done();\n\n\t\treturn segments;\n\t}\n\n\t// return the appropriate API depending on what we're doing\n\tif (!selfIntersection){\n\t\t// performing combination of polygons, so only deal with already-processed segments\n\t\treturn {\n\t\t\tcalculate: function(segments1, inverted1, segments2, inverted2){\n\t\t\t\t// segmentsX come from the self-intersection API, or this API\n\t\t\t\t// invertedX is whether we treat that list of segments as an inverted polygon or not\n\t\t\t\t// returns segments that can be used for further operations\n\t\t\t\tsegments1.forEach(function(seg){\n\t\t\t\t\teventAddSegment(segmentCopy(seg.start, seg.end, seg), true);\n\t\t\t\t});\n\t\t\t\tsegments2.forEach(function(seg){\n\t\t\t\t\teventAddSegment(segmentCopy(seg.start, seg.end, seg), false);\n\t\t\t\t});\n\t\t\t\treturn calculate(inverted1, inverted2);\n\t\t\t}\n\t\t};\n\t}\n\n\t// otherwise, performing self-intersection, so deal with regions\n\treturn {\n\t\taddRegion: function(region){\n\t\t\t// regions are a list of points:\n\t\t\t//  [ [0, 0], [100, 0], [50, 100] ]\n\t\t\t// you can add multiple regions before running calculate\n\t\t\tvar pt1;\n\t\t\tvar pt2 = region[region.length - 1];\n\t\t\tfor (var i = 0; i < region.length; i++){\n\t\t\t\tpt1 = pt2;\n\t\t\t\tpt2 = region[i];\n\n\t\t\t\tvar forward = eps.pointsCompare(pt1, pt2);\n\t\t\t\tif (forward === 0) // points are equal, so we have a zero-length segment\n\t\t\t\t\tcontinue; // just skip it\n\n\t\t\t\teventAddSegment(\n\t\t\t\t\tsegmentNew(\n\t\t\t\t\t\tforward < 0 ? pt1 : pt2,\n\t\t\t\t\t\tforward < 0 ? pt2 : pt1\n\t\t\t\t\t),\n\t\t\t\t\ttrue\n\t\t\t\t);\n\t\t\t}\n\t\t},\n\t\tcalculate: function(inverted){\n\t\t\t// is the polygon inverted?\n\t\t\t// returns segments\n\t\t\treturn calculate(inverted, false);\n\t\t}\n\t};\n}\n\nmodule.exports = Intersecter;\n","// (c) Copyright 2016, Sean Connelly (@voidqk), http://syntheti.cc\n// MIT License\n// Project Home: https://github.com/voidqk/polybooljs\n\n//\n// simple linked list implementation that allows you to traverse down nodes and save positions\n//\n\nvar LinkedList = {\n\tcreate: function(){\n\t\tvar my = {\n\t\t\troot: { root: true, next: null },\n\t\t\texists: function(node){\n\t\t\t\tif (node === null || node === my.root)\n\t\t\t\t\treturn false;\n\t\t\t\treturn true;\n\t\t\t},\n\t\t\tisEmpty: function(){\n\t\t\t\treturn my.root.next === null;\n\t\t\t},\n\t\t\tgetHead: function(){\n\t\t\t\treturn my.root.next;\n\t\t\t},\n\t\t\tinsertBefore: function(node, check){\n\t\t\t\tvar last = my.root;\n\t\t\t\tvar here = my.root.next;\n\t\t\t\twhile (here !== null){\n\t\t\t\t\tif (check(here)){\n\t\t\t\t\t\tnode.prev = here.prev;\n\t\t\t\t\t\tnode.next = here;\n\t\t\t\t\t\there.prev.next = node;\n\t\t\t\t\t\there.prev = node;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tlast = here;\n\t\t\t\t\there = here.next;\n\t\t\t\t}\n\t\t\t\tlast.next = node;\n\t\t\t\tnode.prev = last;\n\t\t\t\tnode.next = null;\n\t\t\t},\n\t\t\tfindTransition: function(check){\n\t\t\t\tvar prev = my.root;\n\t\t\t\tvar here = my.root.next;\n\t\t\t\twhile (here !== null){\n\t\t\t\t\tif (check(here))\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tprev = here;\n\t\t\t\t\there = here.next;\n\t\t\t\t}\n\t\t\t\treturn {\n\t\t\t\t\tbefore: prev === my.root ? null : prev,\n\t\t\t\t\tafter: here,\n\t\t\t\t\tinsert: function(node){\n\t\t\t\t\t\tnode.prev = prev;\n\t\t\t\t\t\tnode.next = here;\n\t\t\t\t\t\tprev.next = node;\n\t\t\t\t\t\tif (here !== null)\n\t\t\t\t\t\t\there.prev = node;\n\t\t\t\t\t\treturn node;\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\t};\n\t\treturn my;\n\t},\n\tnode: function(data){\n\t\tdata.prev = null;\n\t\tdata.next = null;\n\t\tdata.remove = function(){\n\t\t\tdata.prev.next = data.next;\n\t\t\tif (data.next)\n\t\t\t\tdata.next.prev = data.prev;\n\t\t\tdata.prev = null;\n\t\t\tdata.next = null;\n\t\t};\n\t\treturn data;\n\t}\n};\n\nmodule.exports = LinkedList;\n","// (c) Copyright 2016, Sean Connelly (@voidqk), http://syntheti.cc\n// MIT License\n// Project Home: https://github.com/voidqk/polybooljs\n\n//\n// converts a list of segments into a list of regions, while also removing unnecessary verticies\n//\n\nfunction SegmentChainer(segments, eps, buildLog){\n\tvar chains = [];\n\tvar regions = [];\n\n\tsegments.forEach(function(seg){\n\t\tvar pt1 = seg.start;\n\t\tvar pt2 = seg.end;\n\t\tif (eps.pointsSame(pt1, pt2)){\n\t\t\tconsole.warn('PolyBool: Warning: Zero-length segment detected; your epsilon is ' +\n\t\t\t\t'probably too small or too large');\n\t\t\treturn;\n\t\t}\n\n\t\tif (buildLog)\n\t\t\tbuildLog.chainStart(seg);\n\n\t\t// search for two chains that this segment matches\n\t\tvar first_match = {\n\t\t\tindex: 0,\n\t\t\tmatches_head: false,\n\t\t\tmatches_pt1: false\n\t\t};\n\t\tvar second_match = {\n\t\t\tindex: 0,\n\t\t\tmatches_head: false,\n\t\t\tmatches_pt1: false\n\t\t};\n\t\tvar next_match = first_match;\n\t\tfunction setMatch(index, matches_head, matches_pt1){\n\t\t\t// return true if we've matched twice\n\t\t\tnext_match.index = index;\n\t\t\tnext_match.matches_head = matches_head;\n\t\t\tnext_match.matches_pt1 = matches_pt1;\n\t\t\tif (next_match === first_match){\n\t\t\t\tnext_match = second_match;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tnext_match = null;\n\t\t\treturn true; // we've matched twice, we're done here\n\t\t}\n\t\tfor (var i = 0; i < chains.length; i++){\n\t\t\tvar chain = chains[i];\n\t\t\tvar head  = chain[0];\n\t\t\tvar head2 = chain[1];\n\t\t\tvar tail  = chain[chain.length - 1];\n\t\t\tvar tail2 = chain[chain.length - 2];\n\t\t\tif (eps.pointsSame(head, pt1)){\n\t\t\t\tif (setMatch(i, true, true))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (eps.pointsSame(head, pt2)){\n\t\t\t\tif (setMatch(i, true, false))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (eps.pointsSame(tail, pt1)){\n\t\t\t\tif (setMatch(i, false, true))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (eps.pointsSame(tail, pt2)){\n\t\t\t\tif (setMatch(i, false, false))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (next_match === first_match){\n\t\t\t// we didn't match anything, so create a new chain\n\t\t\tchains.push([ pt1, pt2 ]);\n\t\t\tif (buildLog)\n\t\t\t\tbuildLog.chainNew(pt1, pt2);\n\t\t\treturn;\n\t\t}\n\n\t\tif (next_match === second_match){\n\t\t\t// we matched a single chain\n\n\t\t\tif (buildLog)\n\t\t\t\tbuildLog.chainMatch(first_match.index);\n\n\t\t\t// add the other point to the apporpriate end, and check to see if we've closed the\n\t\t\t// chain into a loop\n\n\t\t\tvar index = first_match.index;\n\t\t\tvar pt = first_match.matches_pt1 ? pt2 : pt1; // if we matched pt1, then we add pt2, etc\n\t\t\tvar addToHead = first_match.matches_head; // if we matched at head, then add to the head\n\n\t\t\tvar chain = chains[index];\n\t\t\tvar grow  = addToHead ? chain[0] : chain[chain.length - 1];\n\t\t\tvar grow2 = addToHead ? chain[1] : chain[chain.length - 2];\n\t\t\tvar oppo  = addToHead ? chain[chain.length - 1] : chain[0];\n\t\t\tvar oppo2 = addToHead ? chain[chain.length - 2] : chain[1];\n\n\t\t\tif (eps.pointsCollinear(grow2, grow, pt)){\n\t\t\t\t// grow isn't needed because it's directly between grow2 and pt:\n\t\t\t\t// grow2 ---grow---> pt\n\t\t\t\tif (addToHead){\n\t\t\t\t\tif (buildLog)\n\t\t\t\t\t\tbuildLog.chainRemoveHead(first_match.index, pt);\n\t\t\t\t\tchain.shift();\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif (buildLog)\n\t\t\t\t\t\tbuildLog.chainRemoveTail(first_match.index, pt);\n\t\t\t\t\tchain.pop();\n\t\t\t\t}\n\t\t\t\tgrow = grow2; // old grow is gone... new grow is what grow2 was\n\t\t\t}\n\n\t\t\tif (eps.pointsSame(oppo, pt)){\n\t\t\t\t// we're closing the loop, so remove chain from chains\n\t\t\t\tchains.splice(index, 1);\n\n\t\t\t\tif (eps.pointsCollinear(oppo2, oppo, grow)){\n\t\t\t\t\t// oppo isn't needed because it's directly between oppo2 and grow:\n\t\t\t\t\t// oppo2 ---oppo--->grow\n\t\t\t\t\tif (addToHead){\n\t\t\t\t\t\tif (buildLog)\n\t\t\t\t\t\t\tbuildLog.chainRemoveTail(first_match.index, grow);\n\t\t\t\t\t\tchain.pop();\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tif (buildLog)\n\t\t\t\t\t\t\tbuildLog.chainRemoveHead(first_match.index, grow);\n\t\t\t\t\t\tchain.shift();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (buildLog)\n\t\t\t\t\tbuildLog.chainClose(first_match.index);\n\n\t\t\t\t// we have a closed chain!\n\t\t\t\tregions.push(chain);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// not closing a loop, so just add it to the apporpriate side\n\t\t\tif (addToHead){\n\t\t\t\tif (buildLog)\n\t\t\t\t\tbuildLog.chainAddHead(first_match.index, pt);\n\t\t\t\tchain.unshift(pt);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif (buildLog)\n\t\t\t\t\tbuildLog.chainAddTail(first_match.index, pt);\n\t\t\t\tchain.push(pt);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\t// otherwise, we matched two chains, so we need to combine those chains together\n\n\t\tfunction reverseChain(index){\n\t\t\tif (buildLog)\n\t\t\t\tbuildLog.chainReverse(index);\n\t\t\tchains[index].reverse(); // gee, that's easy\n\t\t}\n\n\t\tfunction appendChain(index1, index2){\n\t\t\t// index1 gets index2 appended to it, and index2 is removed\n\t\t\tvar chain1 = chains[index1];\n\t\t\tvar chain2 = chains[index2];\n\t\t\tvar tail  = chain1[chain1.length - 1];\n\t\t\tvar tail2 = chain1[chain1.length - 2];\n\t\t\tvar head  = chain2[0];\n\t\t\tvar head2 = chain2[1];\n\n\t\t\tif (eps.pointsCollinear(tail2, tail, head)){\n\t\t\t\t// tail isn't needed because it's directly between tail2 and head\n\t\t\t\t// tail2 ---tail---> head\n\t\t\t\tif (buildLog)\n\t\t\t\t\tbuildLog.chainRemoveTail(index1, tail);\n\t\t\t\tchain1.pop();\n\t\t\t\ttail = tail2; // old tail is gone... new tail is what tail2 was\n\t\t\t}\n\n\t\t\tif (eps.pointsCollinear(tail, head, head2)){\n\t\t\t\t// head isn't needed because it's directly between tail and head2\n\t\t\t\t// tail ---head---> head2\n\t\t\t\tif (buildLog)\n\t\t\t\t\tbuildLog.chainRemoveHead(index2, head);\n\t\t\t\tchain2.shift();\n\t\t\t}\n\n\t\t\tif (buildLog)\n\t\t\t\tbuildLog.chainJoin(index1, index2);\n\t\t\tchains[index1] = chain1.concat(chain2);\n\t\t\tchains.splice(index2, 1);\n\t\t}\n\n\t\tvar F = first_match.index;\n\t\tvar S = second_match.index;\n\n\t\tif (buildLog)\n\t\t\tbuildLog.chainConnect(F, S);\n\n\t\tvar reverseF = chains[F].length < chains[S].length; // reverse the shorter chain, if needed\n\t\tif (first_match.matches_head){\n\t\t\tif (second_match.matches_head){\n\t\t\t\tif (reverseF){\n\t\t\t\t\t// <<<< F <<<< --- >>>> S >>>>\n\t\t\t\t\treverseChain(F);\n\t\t\t\t\t// >>>> F >>>> --- >>>> S >>>>\n\t\t\t\t\tappendChain(F, S);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\t// <<<< F <<<< --- >>>> S >>>>\n\t\t\t\t\treverseChain(S);\n\t\t\t\t\t// <<<< F <<<< --- <<<< S <<<<   logically same as:\n\t\t\t\t\t// >>>> S >>>> --- >>>> F >>>>\n\t\t\t\t\tappendChain(S, F);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\t// <<<< F <<<< --- <<<< S <<<<   logically same as:\n\t\t\t\t// >>>> S >>>> --- >>>> F >>>>\n\t\t\t\tappendChain(S, F);\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tif (second_match.matches_head){\n\t\t\t\t// >>>> F >>>> --- >>>> S >>>>\n\t\t\t\tappendChain(F, S);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif (reverseF){\n\t\t\t\t\t// >>>> F >>>> --- <<<< S <<<<\n\t\t\t\t\treverseChain(F);\n\t\t\t\t\t// <<<< F <<<< --- <<<< S <<<<   logically same as:\n\t\t\t\t\t// >>>> S >>>> --- >>>> F >>>>\n\t\t\t\t\tappendChain(S, F);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\t// >>>> F >>>> --- <<<< S <<<<\n\t\t\t\t\treverseChain(S);\n\t\t\t\t\t// >>>> F >>>> --- >>>> S >>>>\n\t\t\t\t\tappendChain(F, S);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n\n\treturn regions;\n}\n\nmodule.exports = SegmentChainer;\n","// (c) Copyright 2016, Sean Connelly (@voidqk), http://syntheti.cc\n// MIT License\n// Project Home: https://github.com/voidqk/polybooljs\n\n//\n// filter a list of segments based on boolean operations\n//\n\nfunction select(segments, selection, buildLog){\n\tvar result = [];\n\tsegments.forEach(function(seg){\n\t\tvar index =\n\t\t\t(seg.myFill.above ? 8 : 0) +\n\t\t\t(seg.myFill.below ? 4 : 0) +\n\t\t\t((seg.otherFill && seg.otherFill.above) ? 2 : 0) +\n\t\t\t((seg.otherFill && seg.otherFill.below) ? 1 : 0);\n\t\tif (selection[index] !== 0){\n\t\t\t// copy the segment to the results, while also calculating the fill status\n\t\t\tresult.push({\n\t\t\t\tid: buildLog ? buildLog.segmentId() : -1,\n\t\t\t\tstart: seg.start,\n\t\t\t\tend: seg.end,\n\t\t\t\tmyFill: {\n\t\t\t\t\tabove: selection[index] === 1, // 1 if filled above\n\t\t\t\t\tbelow: selection[index] === 2  // 2 if filled below\n\t\t\t\t},\n\t\t\t\totherFill: null\n\t\t\t});\n\t\t}\n\t});\n\n\tif (buildLog)\n\t\tbuildLog.selected(result);\n\n\treturn result;\n}\n\nvar SegmentSelector = {\n\tunion: function(segments, buildLog){ // primary | secondary\n\t\t// above1 below1 above2 below2    Keep?               Value\n\t\t//    0      0      0      0   =>   no                  0\n\t\t//    0      0      0      1   =>   yes filled below    2\n\t\t//    0      0      1      0   =>   yes filled above    1\n\t\t//    0      0      1      1   =>   no                  0\n\t\t//    0      1      0      0   =>   yes filled below    2\n\t\t//    0      1      0      1   =>   yes filled below    2\n\t\t//    0      1      1      0   =>   no                  0\n\t\t//    0      1      1      1   =>   no                  0\n\t\t//    1      0      0      0   =>   yes filled above    1\n\t\t//    1      0      0      1   =>   no                  0\n\t\t//    1      0      1      0   =>   yes filled above    1\n\t\t//    1      0      1      1   =>   no                  0\n\t\t//    1      1      0      0   =>   no                  0\n\t\t//    1      1      0      1   =>   no                  0\n\t\t//    1      1      1      0   =>   no                  0\n\t\t//    1      1      1      1   =>   no                  0\n\t\treturn select(segments, [\n\t\t\t0, 2, 1, 0,\n\t\t\t2, 2, 0, 0,\n\t\t\t1, 0, 1, 0,\n\t\t\t0, 0, 0, 0\n\t\t], buildLog);\n\t},\n\tintersect: function(segments, buildLog){ // primary & secondary\n\t\t// above1 below1 above2 below2    Keep?               Value\n\t\t//    0      0      0      0   =>   no                  0\n\t\t//    0      0      0      1   =>   no                  0\n\t\t//    0      0      1      0   =>   no                  0\n\t\t//    0      0      1      1   =>   no                  0\n\t\t//    0      1      0      0   =>   no                  0\n\t\t//    0      1      0      1   =>   yes filled below    2\n\t\t//    0      1      1      0   =>   no                  0\n\t\t//    0      1      1      1   =>   yes filled below    2\n\t\t//    1      0      0      0   =>   no                  0\n\t\t//    1      0      0      1   =>   no                  0\n\t\t//    1      0      1      0   =>   yes filled above    1\n\t\t//    1      0      1      1   =>   yes filled above    1\n\t\t//    1      1      0      0   =>   no                  0\n\t\t//    1      1      0      1   =>   yes filled below    2\n\t\t//    1      1      1      0   =>   yes filled above    1\n\t\t//    1      1      1      1   =>   no                  0\n\t\treturn select(segments, [\n\t\t\t0, 0, 0, 0,\n\t\t\t0, 2, 0, 2,\n\t\t\t0, 0, 1, 1,\n\t\t\t0, 2, 1, 0\n\t\t], buildLog);\n\t},\n\tdifference: function(segments, buildLog){ // primary - secondary\n\t\t// above1 below1 above2 below2    Keep?               Value\n\t\t//    0      0      0      0   =>   no                  0\n\t\t//    0      0      0      1   =>   no                  0\n\t\t//    0      0      1      0   =>   no                  0\n\t\t//    0      0      1      1   =>   no                  0\n\t\t//    0      1      0      0   =>   yes filled below    2\n\t\t//    0      1      0      1   =>   no                  0\n\t\t//    0      1      1      0   =>   yes filled below    2\n\t\t//    0      1      1      1   =>   no                  0\n\t\t//    1      0      0      0   =>   yes filled above    1\n\t\t//    1      0      0      1   =>   yes filled above    1\n\t\t//    1      0      1      0   =>   no                  0\n\t\t//    1      0      1      1   =>   no                  0\n\t\t//    1      1      0      0   =>   no                  0\n\t\t//    1      1      0      1   =>   yes filled above    1\n\t\t//    1      1      1      0   =>   yes filled below    2\n\t\t//    1      1      1      1   =>   no                  0\n\t\treturn select(segments, [\n\t\t\t0, 0, 0, 0,\n\t\t\t2, 0, 2, 0,\n\t\t\t1, 1, 0, 0,\n\t\t\t0, 1, 2, 0\n\t\t], buildLog);\n\t},\n\tdifferenceRev: function(segments, buildLog){ // secondary - primary\n\t\t// above1 below1 above2 below2    Keep?               Value\n\t\t//    0      0      0      0   =>   no                  0\n\t\t//    0      0      0      1   =>   yes filled below    2\n\t\t//    0      0      1      0   =>   yes filled above    1\n\t\t//    0      0      1      1   =>   no                  0\n\t\t//    0      1      0      0   =>   no                  0\n\t\t//    0      1      0      1   =>   no                  0\n\t\t//    0      1      1      0   =>   yes filled above    1\n\t\t//    0      1      1      1   =>   yes filled above    1\n\t\t//    1      0      0      0   =>   no                  0\n\t\t//    1      0      0      1   =>   yes filled below    2\n\t\t//    1      0      1      0   =>   no                  0\n\t\t//    1      0      1      1   =>   yes filled below    2\n\t\t//    1      1      0      0   =>   no                  0\n\t\t//    1      1      0      1   =>   no                  0\n\t\t//    1      1      1      0   =>   no                  0\n\t\t//    1      1      1      1   =>   no                  0\n\t\treturn select(segments, [\n\t\t\t0, 2, 1, 0,\n\t\t\t0, 0, 1, 1,\n\t\t\t0, 2, 0, 2,\n\t\t\t0, 0, 0, 0\n\t\t], buildLog);\n\t},\n\txor: function(segments, buildLog){ // primary ^ secondary\n\t\t// above1 below1 above2 below2    Keep?               Value\n\t\t//    0      0      0      0   =>   no                  0\n\t\t//    0      0      0      1   =>   yes filled below    2\n\t\t//    0      0      1      0   =>   yes filled above    1\n\t\t//    0      0      1      1   =>   no                  0\n\t\t//    0      1      0      0   =>   yes filled below    2\n\t\t//    0      1      0      1   =>   no                  0\n\t\t//    0      1      1      0   =>   no                  0\n\t\t//    0      1      1      1   =>   yes filled above    1\n\t\t//    1      0      0      0   =>   yes filled above    1\n\t\t//    1      0      0      1   =>   no                  0\n\t\t//    1      0      1      0   =>   no                  0\n\t\t//    1      0      1      1   =>   yes filled below    2\n\t\t//    1      1      0      0   =>   no                  0\n\t\t//    1      1      0      1   =>   yes filled above    1\n\t\t//    1      1      1      0   =>   yes filled below    2\n\t\t//    1      1      1      1   =>   no                  0\n\t\treturn select(segments, [\n\t\t\t0, 2, 1, 0,\n\t\t\t2, 0, 0, 1,\n\t\t\t1, 0, 0, 2,\n\t\t\t0, 1, 2, 0\n\t\t], buildLog);\n\t}\n};\n\nmodule.exports = SegmentSelector;\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","var webpackQueues = typeof Symbol === \"function\" ? Symbol(\"webpack queues\") : \"__webpack_queues__\";\nvar webpackExports = typeof Symbol === \"function\" ? Symbol(\"webpack exports\") : \"__webpack_exports__\";\nvar webpackError = typeof Symbol === \"function\" ? Symbol(\"webpack error\") : \"__webpack_error__\";\nvar resolveQueue = (queue) => {\n\tif(queue && queue.d < 1) {\n\t\tqueue.d = 1;\n\t\tqueue.forEach((fn) => (fn.r--));\n\t\tqueue.forEach((fn) => (fn.r-- ? fn.r++ : fn()));\n\t}\n}\nvar wrapDeps = (deps) => (deps.map((dep) => {\n\tif(dep !== null && typeof dep === \"object\") {\n\t\tif(dep[webpackQueues]) return dep;\n\t\tif(dep.then) {\n\t\t\tvar queue = [];\n\t\t\tqueue.d = 0;\n\t\t\tdep.then((r) => {\n\t\t\t\tobj[webpackExports] = r;\n\t\t\t\tresolveQueue(queue);\n\t\t\t}, (e) => {\n\t\t\t\tobj[webpackError] = e;\n\t\t\t\tresolveQueue(queue);\n\t\t\t});\n\t\t\tvar obj = {};\n\t\t\tobj[webpackQueues] = (fn) => (fn(queue));\n\t\t\treturn obj;\n\t\t}\n\t}\n\tvar ret = {};\n\tret[webpackQueues] = x => {};\n\tret[webpackExports] = dep;\n\treturn ret;\n}));\n__webpack_require__.a = (module, body, hasAwait) => {\n\tvar queue;\n\thasAwait && ((queue = []).d = -1);\n\tvar depQueues = new Set();\n\tvar exports = module.exports;\n\tvar currentDeps;\n\tvar outerResolve;\n\tvar reject;\n\tvar promise = new Promise((resolve, rej) => {\n\t\treject = rej;\n\t\touterResolve = resolve;\n\t});\n\tpromise[webpackExports] = exports;\n\tpromise[webpackQueues] = (fn) => (queue && fn(queue), depQueues.forEach(fn), promise[\"catch\"](x => {}));\n\tmodule.exports = promise;\n\tbody((deps) => {\n\t\tcurrentDeps = wrapDeps(deps);\n\t\tvar fn;\n\t\tvar getResult = () => (currentDeps.map((d) => {\n\t\t\tif(d[webpackError]) throw d[webpackError];\n\t\t\treturn d[webpackExports];\n\t\t}))\n\t\tvar promise = new Promise((resolve) => {\n\t\t\tfn = () => (resolve(getResult));\n\t\t\tfn.r = 0;\n\t\t\tvar fnQueue = (q) => (q !== queue && !depQueues.has(q) && (depQueues.add(q), q && !q.d && (fn.r++, q.push(fn))));\n\t\t\tcurrentDeps.map((dep) => (dep[webpackQueues](fnQueue)));\n\t\t});\n\t\treturn fn.r ? promise : getResult();\n\t}, (err) => ((err ? reject(promise[webpackError] = err) : outerResolve(exports)), resolveQueue(queue)));\n\tqueue && queue.d < 0 && (queue.d = 0);\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","","// startup\n// Load entry module and return exports\n// This entry module used 'module' so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(\"../assets/js/game/index.js\");\n",""],"names":[],"sourceRoot":""}